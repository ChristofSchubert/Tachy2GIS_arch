# -*- coding: utf-8 -*-
"""
/***************************************************************************
 T2G_Arch
                                 A QGIS plugin
 Archäologie-PlugIn für Tachy2Gis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-17
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Daniel Timmel
        email                :
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QSize, QTimer, pyqtSlot, pyqtSignal, QPoint, QVariant, QObject
from PyQt5.QtGui import *#QIcon, QPixmap
from PyQt5.QtWidgets import *#QAction, QMessageBox, QFileDialog, QTreeWidgetItem, QInputDialog
from qgis.core import QgsProject, QgsExpressionContextUtils, QgsMessageLog, QgsVectorLayer, QgsFeature,QgsWkbTypes, QgsField, QgsCoordinateReferenceSystem
from qgis.utils import iface, plugins
from qgis.gui import QgisInterface
from PyQt5.QtWidgets import QApplication as qApp
from .t2g_arch_dockwidget import T2G_ArchDockWidget
import os, csv, math
from datetime import date, datetime
import operator, subprocess
import os.path
import uuid
from configparser import ConfigParser
from osgeo import gdal
from .functions import *
from .textadjustment import *
from .ExtDialoge.myDlgDrucklayout import *
from .ExtDialoge.myDlgAttributverwaltung import *
from .ExtDialoge.myDwgFeatureQuestion import *
from .identifygeometry import IdentifyGeometry
from .ExtDialoge.myDwgFeatureQuestion import FeatureQuestionDockWidget
from .ExtDialoge.myDlgGeometryCheck import GeometryCheckDockWidget
from .ExtDialoge.myDlgRasterLayerView import RasterLayerViewDockWidget
from .ExtDialoge.myDlgSettings import *
from .ExtDialoge.myDwgLookForMissingAttributes import LookForMissingAttributesDockWidget
from .messen.messen import Measurement

#import ezdxf

from .transformation.transformation_gui import TransformationGui
from .geoEdit.geo_edit import GeoEdit
from .profile.profile import Profile

VERSION = 'LfA Sachsen ' + 'V 0.8.0' + ' für Qgis 3.20 -'

FN_PROFILNUMMER = 'prof_nr'  # Feldname in der die Profilnummer steht
FN_DEF_FOTOENTZERRPUNKT = 'obj_type'  # Feldname in der die Entzerrpunkt-definition steht
AW_FOTOENTZERRPUNKT = 'Fotoentzerrpunkt'  # Entzerrpunkt-definition

class T2G_Arch:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        print('constructor')
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        if Qgis.QGIS_VERSION_INT < 32000:
            box = QMessageBox()
            box.setText(str(Qgis.QGIS_VERSION_INT))
            box.exec_()
            raise SystemExit

        # Save reference to the QGIS interface
        self.iface = iface
        self.mapCanvas = iface.mapCanvas()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'T2G_Arch_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.myactions = []
        self.menu = self.tr(u'&T2G Archäologie')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'T2G_Arch')
        self.toolbar.setObjectName(u'T2G_Arch')

        #print "** INITIALIZING T2G_Arch"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('T2G_Arch', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        print('startRun')
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        print('initGui')
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        iconpfad = os.path.join(os.path.dirname(__file__), 'Icons')
        icon_path = os.path.join(self.plugin_dir,'icon.png')
        self.add_action(
            icon_path,
            text=self.tr(u'T2G-Archäologie'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #my Toolbuttons
        iconVisibleApp = QIcon(os.path.join(iconpfad, 'Sichtbar_an.gif'))
        self.actionPluginSichtbarkeit = QAction(iconVisibleApp, u'Plugin Sichtbarkeit', self.iface.mainWindow())
        self.actionPluginSichtbarkeit.setCheckable(True)
        self.actionPluginSichtbarkeit.triggered.connect(self.pluginSichtbarkeit)
        self.toolbar.addAction(self.actionPluginSichtbarkeit)
        self.myactions.append(self.actionPluginSichtbarkeit)

        icon = QIcon(os.path.join(iconpfad, 'ordner-open.png'))
        self.actionProjectPfadExplorer = QAction(icon, u'Projektexplorer öffnen', self.iface.mainWindow())
        #self.actionProjectPfadExplorer.setCheckable(True)
        self.actionProjectPfadExplorer.triggered.connect(self.projectPfadExplorer)
        self.toolbar.addAction(self.actionProjectPfadExplorer)
        self.myactions.append(self.actionProjectPfadExplorer)

        icon2 = QIcon(os.path.join(iconpfad, 'FeatureQuest.gif'))
        self.actionFeatureQuestion = QAction(icon2, u'Geometrie abfragen', self.iface.mainWindow())
        #self.actionFeatureQuestion.setCheckable(True)
        self.actionFeatureQuestion.triggered.connect(self.featureQuestion)
        self.toolbar.addAction(self.actionFeatureQuestion)
        self.myactions.append(self.actionFeatureQuestion)
        self.toolbar.addSeparator()

        #Vermessung
        icon3 = QIcon(os.path.join(iconpfad, 'Einstellungen.gif'))
        icon4 = QIcon(os.path.join(iconpfad, 'media-floppy.png'))
        icon5 = QIcon(os.path.join(iconpfad, 'Befundnr.gif'))

        self.action2 = QAction(icon4, u'Tagesprojekt Sichern', self.iface.mainWindow())
        self.action3 = QAction(icon5, u'Befundnr setzen', self.iface.mainWindow())
        self.popupMenu = QMenu()
        self.myactions.append(self.popupMenu)

        self.popupMenu.addAction(self.action2)
        self.popupMenu.addAction(self.action3)


        self.action2.triggered.connect(self.dayProjectSave)
        #self.action3.triggered.connect(self.klickPointLabel)

        self.toolButton = QToolButton()
        self.toolButton.setMenu(self.popupMenu)
        self.toolButton.setDefaultAction(self.action2)
        self.toolButton.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton)
        self.myactions.append(self.toolButton)

        # Tools Allgemein
        icon6 = QIcon(os.path.join(iconpfad, 'PunktImp.gif'))
        icon7 = QIcon(os.path.join(iconpfad, 'PunktExp.gif'))
        icon8 = QIcon(os.path.join(iconpfad, 'ProfPunktExp.gif'))
        self.action4 = QAction(icon6, u'Punkt Import', self.iface.mainWindow())
        self.action5 = QAction(icon7, u'Punkt Export', self.iface.mainWindow())
        self.action6 = QAction(icon8, u'Profilentzerrpunkte Export', self.iface.mainWindow())
        self.popupMenu2 = QMenu()
        self.myactions.append(self.popupMenu2)
        self.popupMenu2.addAction(self.action4)
        self.popupMenu2.addAction(self.action5)
        self.popupMenu2.addAction(self.action6)

        self.action4.triggered.connect(self.pointImp)
        self.action5.triggered.connect(self.pointExp)
        self.action6.triggered.connect(self.profEntzpointExp)

        self.toolButton1 = QToolButton()
        self.toolButton1.setMenu(self.popupMenu2)
        self.toolButton1.setDefaultAction(self.action4)
        self.toolButton1.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton1)
        self.myactions.append(self.toolButton1)

        # Tools Geometrie 1
        icon9 = QIcon(os.path.join(iconpfad, 'LineRe.gif'))
        icon10 = QIcon(os.path.join(iconpfad, 'butContactClip.gif'))
        self.action7 = QAction(icon9, u'Linie umdrehen', self.iface.mainWindow())
        self.action8 = QAction(icon10, u'an Geometrie anschließen', self.iface.mainWindow())

        self.popupMenu3 = QMenu()
        self.myactions.append(self.popupMenu3)
        self.popupMenu3.addAction(self.action7)
        self.popupMenu3.addAction(self.action8)

        self.action7.triggered.connect(self.lineFeatureReverse)
        self.action8.triggered.connect(self.contactClip)


        self.toolButton2 = QToolButton()
        self.toolButton2.setMenu(self.popupMenu3)
        self.toolButton2.setDefaultAction(self.action8)
        self.toolButton2.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton2)
        self.myactions.append(self.toolButton2)

        # Raster
        icon11 = QIcon(os.path.join(iconpfad, 'Thumbs.gif'))
        #icon4 = QIcon(os.path.join(iconpfad, 'media-floppy.png'))
        #icon5 = QIcon(os.path.join(iconpfad, 'Befundnr.gif'))
        self.action9 = QAction(icon11, u'Rasterlayer Übersicht', self.iface.mainWindow())
        #self.action2 = QAction(icon4, u'Tagesprojekt Sichern', self.iface.mainWindow())
        #self.action3 = QAction(icon5, u'Befundnr setzen', self.iface.mainWindow())
        self.popupMenu4 = QMenu()
        self.myactions.append(self.popupMenu4)
        self.popupMenu4.addAction(self.action9)
        #self.popupMenu.addAction(self.action2)
        #self.popupMenu.addAction(self.action3)

        self.action9.triggered.connect(self.myDlgRasterLayerShow)
        #self.action2.triggered.connect(self.dayProjectSave)
        #self.action3.triggered.connect(self.klickPointLabel)

        self.toolButton3 = QToolButton()
        self.toolButton3.setMenu(self.popupMenu4)
        self.toolButton3.setDefaultAction(self.action9)
        self.toolButton3.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton3)
        self.myactions.append(self.toolButton3)

        for action in self.myactions:
            action.setEnabled(False)
        self.actions[0].setEnabled(True)

        self.watch = QTimer()
        self.QgisDateiPfad =''
        self.ProjPfad =''
        self.mapTool = IdentifyGeometry(self.mapCanvas)
        self.mapTool.geomIdentified.connect(self.editFeature)
        self.mapToolSel = IdentifyGeometry(self.mapCanvas)
        self.mapToolSel.geomIdentified.connect(self.featureSelect2)
        self.selectedLayer = None
        self.selectedFeature = None

        self.dwFeatureQuestion = None
        self.dwAllLayerQuestion = None

        self.selectFeatures = []
        self.selFeatureTemp = None
        self.abbruch = None
        self.iconpfad = os.path.join(os.path.dirname(__file__), 'Icons')

        self.config = None
        self.newFeaturesIds = []

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        print('onClosePlugin')
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None
        self.pluginIsActive = False

        self.watch.stop()
        self.watch.timeout.disconnect(self.watchEvent)
        for action in self.actions:
            action.setEnabled(False)
        for action in self.myactions:
            action.setEnabled(False)
        self.actions[0].setEnabled(True)




    def unload(self):
        print('unload')
        """Removes the plugin menu item and icon from QGIS GUI."""

        delLayer("Profilentzerrpunkte AAR-Tool")
        #print "** UNLOAD T2G_Arch"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&T2G Archäologie'),
                action)
            self.iface.removeToolBarIcon(action)

        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    ## @brief Run method that loads and starts the plugin
    #
    # @param self
    def run(self):
        print('run')
        """Run method that loads and starts the plugin"""

        #if self.pluginIsActive:
        #    self.actions[0].setEnabled(True)
        #    for action in self.myactions:
        #        action.setEnabled(True)
        if plugins.get('Tachy2GIS-3D_viewer') == None:
            box = QMessageBox()
            box.setText('Tachy2Gis 3D Viewer ist nicht installiert. Wird aber für die Messfunktion benötigt!')
            box.exec_()
            return

        if not self.pluginIsActive:
            self.actions[0].setEnabled(True)
            self.pluginIsActive = True

            self.actions[0].setEnabled(False)
            for action in self.myactions:
                action.setEnabled(True)
            #print "** STARTING T2G_Arch"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = T2G_ArchDockWidget()
                #  connect to provide cleanup on closing of dockwidget
            self.valueTemp1 = None
            self.rubberBand = makerAndRubberbands()
            self.pointMaker = makerAndRubberbands()
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            self.dockwidget.butHilfe.setIcon(QIcon(os.path.join(self.iconpfad, 'Frage.gif')))
            self.dockwidget.butHilfe.setToolTip('Benutzerhandpuch')
            self.dockwidget.butHilfe.clicked.connect(self.help)
            self.dockwidget.butPunktExp.setIcon(QIcon(os.path.join(self.iconpfad, 'PunktExp.gif')))
            self.dockwidget.butPunktExp.setToolTip('Punkte Export')
            self.dockwidget.butPunktExp.clicked.connect(self.pointExp)
            self.dockwidget.butPunktImp.setIcon(QIcon(os.path.join(self.iconpfad, 'PunktImp.gif')))
            self.dockwidget.butPunktImp.setToolTip('Punkte Import')
            self.dockwidget.butProfEntzPunktExp.clicked.connect(self.profEntzpointExp)
            self.dockwidget.butProfEntzPunktExp.setIcon(QIcon(os.path.join(self.iconpfad, 'ProfPunktExp.gif')))
            self.dockwidget.butProfEntzPunktExp.setToolTip('Profilentzerrpunkte Export')
            self.dockwidget.butPunktImp.clicked.connect(self.pointImp)
            self.dockwidget.butSchriftfeld.clicked.connect(self.myDlgDrucklayoutShow)
            self.dockwidget.butSchriftfeld.setIcon(QIcon(os.path.join(self.iconpfad, 'Schriftfeld.jpg')))

            #self.dockwidget.cboSuche.currentIndexChanged.connect(self.ozoom_1_ok)
            self.dockwidget.butObjFind.setIcon(QIcon(os.path.join(self.iconpfad, 'suchen.gif')))
            self.dockwidget.butObjFind.clicked.connect(self.ozoom_1_ok)
            self.dockwidget.cboSuche.setToolTip('Suchen')
            self.dockwidget.pushButton.clicked.connect(self.editLayerEncoding)
            self.dockwidget.butLayerFilter.clicked.connect(self.myDlgAllLayerQuestionShow)
            self.dockwidget.butLayerFilter.setToolTip('Filter auf alle Layer setzen')
            self.dockwidget.butDelAllFeatures.clicked.connect(self.delAllFeature)
            self.dockwidget.butDelAllFeatures.setToolTip('Löscht alle Geometrien auf den 3 Eingabelayern')
            #self.dockwidget.butProfMe.clicked.connect(self.addProfil)
            #self.dockwidget.butProfMe.setIcon(QIcon(os.path.join(self.iconpfad, 'icon.png')))
            self.dockwidget.butAttributverwaltung.clicked.connect(self.myDlgAttributverwaltungShow)

            self.layerLine = QgsProject.instance().mapLayersByName(T2G_ArchDockWidget.eLayerListe()[0])[0]
            self.layerPoly = QgsProject.instance().mapLayersByName(T2G_ArchDockWidget.eLayerListe()[1])[0]
            self.layerPoint = QgsProject.instance().mapLayersByName(T2G_ArchDockWidget.eLayerListe()[2])[0]
            self.layerMesspoint = QgsProject.instance().mapLayersByName('Messpunkte')[0]

            self.layerLine.featuresDeleted.connect(self.__eventFeaturesDeleted)
            self.layerPoly.featuresDeleted.connect(self.__eventFeaturesDeleted)
            self.layerPoint.featuresDeleted.connect(self.__eventFeaturesDeleted)

            self.layerLine.editingStarted.connect(self.eventEditingStarted)
            self.layerPoly.editingStarted.connect(self.eventEditingStarted)
            self.layerPoint.editingStarted.connect(self.eventEditingStarted)

            #self.layerLine.editingStopped.connect(self.eventEditingStopped)
            #self.layerPoly.editingStopped.connect(self.eventEditingStopped)
            #self.layerPoint.editingStopped.connect(self.eventEditingStopped)

            self.layerLine.subsetStringChanged.connect(self.FilterGesetzt)
            self.layerPoly.subsetStringChanged.connect(self.FilterGesetzt)
            self.layerPoint.subsetStringChanged.connect(self.FilterGesetzt)

            self.layerLine.attributeValueChanged.connect(self.__eventAttributeValueChanged)
            self.layerPoly.attributeValueChanged.connect(self.__eventAttributeValueChanged)
            self.layerPoint.attributeValueChanged.connect(self.__eventAttributeValueChanged)

            #self.layerLine.editCommandDestroyed.connect(self.__eventEditCommandDestroyed)
            #self.layerPoly.editCommandDestroyed.connect(self.__eventEditCommandDestroyed)
            #self.layerPoint.editCommandDestroyed.connect(self.__eventEditCommandDestroyed)

            self.layerLine.featureAdded.connect(self.eventFeatureAdded)
            self.layerPoly.featureAdded.connect(self.eventFeatureAdded)
            self.layerPoint.featureAdded.connect(self.eventFeatureAdded)

            self.dockwidget.pushButton_3.clicked.connect(self.dayProjectSave)
            self.dockwidget.pushButton_3.setIcon(QIcon(os.path.join(self.iconpfad, 'media-floppy.png')))

            self.dockwidget.butAllLayfFilterEnt.clicked.connect(self.eventAllLayfFilterEnt)
            self.dockwidget.butAllLayfFilterEnt.setToolTip('Löscht alle Layerfilter')
            self.dockwidget.butAllLayfFilterEnt.setIcon(QIcon(os.path.join(self.iconpfad, 'FilterAllLayerEnt.gif')))
            self.dockwidget.butAllLayFilter.clicked.connect(self.eventAllLayFilter)
            self.dockwidget.butAllLayFilter.setToolTip('Setzt einen Filter auf alle Layer')
            self.dockwidget.butAllLayFilter.setIcon(QIcon(os.path.join(self.iconpfad, 'FilterAllLayer.gif')))
            self.dockwidget.butAllLayBefFilter.clicked.connect(self.eventAllLayBefFilter)
            self.dockwidget.butAllLayBefFilter.setToolTip('Setzt einen Befundfilter auf alle Layer')
            self.dockwidget.butAllLayBefFilter.setIcon(QIcon(os.path.join(self.iconpfad, 'FilterAllLayerBef.gif')))

            self.dockwidget.canvas_clicked = PrintClickedPoint(self.iface.mapCanvas(), self.dockwidget)

            self.dockwidget.pushButton_4.setIcon(QIcon(os.path.join(self.iconpfad, 'V_Jpg-Tif.gif')))
            self.dockwidget.pushButton_4.clicked.connect(self.gtiff2jpg)
            self.dockwidget.pushButton_5.setIcon(QIcon(os.path.join(self.iconpfad, 'cut.gif')))
            self.dockwidget.pushButton_5.clicked.connect(self.rasterCut)
            self.dockwidget.pushButton_6.setIcon(QIcon(os.path.join(self.iconpfad, 'cutmask.gif')))
            self.dockwidget.pushButton_6.clicked.connect(self.setCutMask)
            self.dockwidget.pushButton_7.setIcon(QIcon(os.path.join(self.iconpfad, 'cutmaskdel.gif')))
            self.dockwidget.pushButton_7.clicked.connect(self.delCutMask)
            self.dockwidget.pushButton_11.setIcon(QIcon(os.path.join(self.iconpfad, 'Thumbs.gif')))
            self.dockwidget.pushButton_11.clicked.connect(self.myDlgRasterLayerShow)
            self.dockwidget.pushButton_11.setToolTip('Übersicht der Rasterlayer')

            self.dockwidget.butSet.setIcon(QIcon(os.path.join(self.iconpfad, 'Einstellungen.gif')))
            self.dockwidget.butSet.clicked.connect(self.myDlgSettingsShow)
            self.dockwidget.butSet.setToolTip('Setupdatei bearbeiten')

            self.iface.layerTreeView().currentLayerChanged.connect(self.currentLayerChanged)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)

            #self.dockwidget.toolBox.currentChanged.connect(self.toolbox_currentChanged)
            self.dockwidget.tabWidget_2.currentChanged.connect(self.toolbox_currentChanged)
            self.dockwidget.show()
            self.layerPoly.selectionChanged.connect(self.selectFeatureChanged)

            self.dockwidget.pushButton_9.clicked.connect(self.myDlgFeatureCheckShow)
            self.watch.timeout.connect(self.watchEvent)

            ####################################################################
            ############################# Transformation #######################
            ####################################################################

            tGui = TransformationGui(self.dockwidget, self.iface)
            tGui.setup()
            ####################################################################

            ####################################################################
            ############################# Geometriebearbeitung #################
            ####################################################################

            self.geoEdit = GeoEdit(self, self.iface)
            self.geoEdit.setup()
            ####################################################################

            ####################################################################
            ############################# Profile #################
            ####################################################################

            self.profile = Profile(self, self.iface)
            self.profile.setup()
            ####################################################################

            self.dockwidget.butLookForMissingAttributes.clicked.connect(self.myDwgLookForMissingAttributesShow)
            # Event nach Projektdatei wechsel
            self.iface.projectRead.connect(self.eventReadProject)

            ####################################################################
            ############################# Messen #################
            ####################################################################

            self.t2g = Measurement(self, self.iface)

            ####################################################################

            self.__lastMaxNumber = []
            self.setup()

    def eventReadProject(self):
        """ Event Projekt geladen """
        # Datei- und Projektpfad in Variable speichern
        self.QgisDateiPfad = QgsProject.instance().readPath('./')
        self.ProjPfad = os.path.abspath(os.path.join(self.QgisDateiPfad, "./.."))

        # Config-Datei abarbeiten
        QgsMessageLog.logMessage('Projekt Config.ini laden.', 'T2G Archäologie', Qgis.Info)
        self.config = Configfile(os.path.join(self.ProjPfad,'_System_/config.ini'))
        self.t2g.setconfig(self.config)
        myDlgSettingsView = DlgSettings(self, self.config)
        myDlgSettingsView.setup()
        # Autosave einstellungen setzen
        autoSaveTime = self.config.getValue("AutoSave","time",'10')
        autoSaveEnable = self.config.getValue("AutoSave","enabled",'True')
        if autoSaveEnable == 'True':
            self.watch.start(int(autoSaveTime) * 60000)
            QgsMessageLog.logMessage("Auto Backup: An, " + "Takt " + autoSaveTime + " min" , 'T2G Archäologie', Qgis.Info)
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: An, " + "Takt " + autoSaveTime + " min",
                                           level=Qgis.Info)
        else:
            self.watch.stop()
            QgsMessageLog.logMessage("Auto Backup: Aus", 'T2G Archäologie', Qgis.Info)
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: Aus.",
                                           level=Qgis.Info)

        val = self.config.getValue("Textgröße","value",'0.70')
        textadjustment = Textadjustment(self,val)
        textadjustment.setText()

    def setup(self):
        iface.setActiveLayer(self.layerPoly)

        self.QgisDateiPfad = QgsProject.instance().readPath('./')
        self.ProjPfad = os.path.abspath(os.path.join(self.QgisDateiPfad, "./.."))

        self.dockwidget.butLayerFilter.hide()
        self.dockwidget.butDelAllFeatures.hide()
        self.dockwidget.butAllLayBefFilter.hide()
        self.dockwidget.butAllLayFilter.hide()
        self.dockwidget.butAllLayfFilterEnt.hide()
        self.dockwidget.butLookForMissingAttributes.hide()
        self.dockwidget.label_10.setText(VERSION)

        self.currentLayerChanged()
        self.getMaxValues()

        self.dockwidget.txtPointTemp.hide()
        iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Aufsatz Archäologie für T2G ist einsatzbereit.",
                                       level=Qgis.Info)
        QgsMessageLog.logMessage('Aufsatz Archäologie für T2G ist einsatzbereit.', 'T2G Archäologie', Qgis.Info)

        delSelectFeature()
        self.selectFeatures = []
        QgsMessageLog.logMessage('Überprüfe UUID', 'T2G Archäologie', Qgis.Info)
        iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Überprüfe UUID.", level=Qgis.Info)
        # >uuid ereugen wenn Feld uuid leer
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in list:
            layer.startEditing()
            if layer.dataProvider().fieldNameIndex("uuid") == -1:
                layer.dataProvider().addAttributes([QgsField("uuid", QVariant.String, len=50)])
                fIndex = layer.dataProvider().fieldNameIndex('uuid')
                layer.setDefaultValueDefinition(fIndex, QgsDefaultValue('uuid()'))
                layer.updateFields()
            it = layer.getFeatures(QgsFeatureRequest().setFilterExpression(u'"uuid" IS NULL'))
            #QgsMessageLog.logMessage(str(it.count()), 'T2G Archäologie', Qgis.Info)
            UUid = layer.dataProvider().fieldNameIndex('uuid')
            for feature in it:
                layer.changeAttributeValue(feature.id(), UUid, '{' + str(uuid.uuid4()) + '}')
            layer.commitChanges()
        # <uuid ereugen wenn Feld uuid leer

        self.T2G = plugins.get('Tachy2GIS-3D_viewer')
        self.dockwidget.tabWidget_2.setCurrentIndex(0)
        self.dockwidget.setFixedWidth(233)
        self.iface.actionSelectRectangle().trigger()

        self.FilterGesetzt()

        self.eventReadProject()

    def eventFeatureAdded(self, fid):
        self.newFeaturesIds.append(fid)
        QgsMessageLog.logMessage(str(fid) + ' neu', 'T2G Archäologie', Qgis.Info)
        pass

    def toolbox_currentChanged(self,index):
        QgsMessageLog.logMessage(str(index), 'T2G Archäologie', Qgis.Info)
        if index == 1 or index == 3 or index == 4:
            self.dockwidget.setFixedWidth(440)
        else:
            self.dockwidget.setFixedWidth(233)


    def pluginSichtbarkeit(self):
        if self.dockwidget is None:
            return
        if self.actionPluginSichtbarkeit.isChecked():
            self.dockwidget.hide()
            self.actionPluginSichtbarkeit.setIcon(QIcon(os.path.join(self.iconpfad, 'Sichtbar_aus.gif')))
        else:
            self.dockwidget.show()
            self.actionPluginSichtbarkeit.setIcon(QIcon(os.path.join(self.iconpfad, 'Sichtbar_an.gif')))

    def setCutMask(self):
        cutlayer = QgsProject.instance().mapLayersByName('Schnittmaske')[0]
        actlayer = None
        for layer in QgsProject.instance().mapLayers().values():
            if layer.type() == QgsMapLayer.VectorLayer:
                if layer.selectedFeatureCount() > 0:
                    actlayer = layer
                    break
        if actlayer == None:
            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                           u"Keine Objekte gewählt! Abbruch",
                                           level=Qgis.Critical)
            return
        iface.actionCopyFeatures().trigger()
        iface.setActiveLayer(cutlayer)
        cutlayer.startEditing()
        iface.actionPasteFeatures().trigger()
        cutlayer.commitChanges()
        delSelectFeature()
        self.iface.actionSelectRectangle().trigger()

    def delCutMask(self):
        cutlayer = QgsProject.instance().mapLayersByName('Schnittmaske')[0]
        cutlayer.startEditing()
        listOfIds = [feat.id() for feat in cutlayer.getFeatures()]
        cutlayer.deleteFeatures(listOfIds)
        cutlayer.commitChanges()
        iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                       u"Maskenlayer gelöscht",
                                       level=Qgis.Info)

    def rasterCut(self):
        # Layer des zu schneidenden Bildes
        layer = self.iface.mapCanvas().currentLayer()

        if layer.type() != QgsMapLayer.RasterLayer:
            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                           u"Layer ist kein Rasterlayer!",
                                           level=Qgis.Critical)
            return

        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle('Frage')
        box.setText('Neue Schnittmaske erstellen oder vorh. Maske verwenden.')
        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText('Neu')
        buttonY.setToolTip('Erstellt eine Schnittmaske durch zeichnen eines Polygons.')
        buttonN = box.button(QMessageBox.No)
        buttonN.setText('vorh. Maske')
        buttonN.setToolTip('Nutzt die Objekte im Layer Schnittmaske')
        box.exec_()
        # Layer mit Schnittmaske/n in Variable speichern und activ setzen
        cutlayer = QgsProject.instance().mapLayersByName('Schnittmaske')[0]
        iface.setActiveLayer(cutlayer)
        # Auswahl neue Schnittmaske
        if box.clickedButton() == buttonY:
            #Schnittmasken Layer zum editing öffnen
            cutlayer.startEditing()
            # alle Geometrien löschen
            listOfIds = [feat.id() for feat in cutlayer.getFeatures()]
            cutlayer.deleteFeatures(listOfIds)
            # Qgis Kartenfenster aktuallisieren
            self.iface.mapCanvas().refresh()
            # Aktion Neues Objekt auslösen
            iface.actionAddFeature().trigger()
            # Warten bis ein neues Objekt gezeichnet wurde
            while cutlayer.featureCount() < 1:
                QApplication.processEvents()
            # Änderungen übernehmen
            cutlayer.commitChanges()
        # Auswahl Vorhandene Schnittmaske
        elif box.clickedButton() == buttonN:
            if cutlayer.featureCount() == 0:
                iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                               u"Keine Objekte auf Maskenlayer vorhanden! Abbruch",
                                               level=Qgis.Critical)
                return
        else:
            # Bei keiner Auswahl Abbruch
            return
        # Layer des zu schneidenden Bildes aktiv setzen
        iface.setActiveLayer(layer)

        # Layerpfad in Variable speichern
        input = os.path.abspath(str(unicode(layer.source())))
        # Programmteil zum schneideen des Bildes
        try:
            # Maskenlayerpfad in Variable speichern
            masklayerpfad = str(cutlayer.source()).split("|")[0]
            masklayername = 'Schnittmaske'
            # Layer Koordinatensysteme in Variable speichern
            inputsrs = layer.crs().authid()
            outputsrs = layer.crs().authid()

            temp_input_raster = None
            temp_output_raster = None
            # Pfad Eingaberaster in Variable speichern
            temp_input_raster =  input
            # Pfad Ausgaberaster in Variable speichern
            temp_output_raster = os.path.splitext(input)[0] + '_cut' + os.path.splitext(input)[1]

            items = ("keine", "75", "50", "25")
            kompress = None
            kompressv, ok = QInputDialog.getItem(None, 'Kompression', 'JPEG-Qualität eingeben', items, 0, False)
            if ok != True:
                # Abbruch
                return
            else:
                # Kompressionsvariable setzen
                if kompressv == 'keine':
                    kompress = ''
                else:
                    kompress = '-co COMPRESS=JPEG -co JPEG_QUALITY=' + kompressv
            # Gdal Komandozeile zusammensetzen
            string = r'gdalwarp' + \
                     ' -s_srs ' + inputsrs + \
                     ' -t_srs ' + outputsrs + \
                     ' -of GTiff -cutline "' + masklayerpfad + '" -cl ' + masklayername + \
                     ' -crop_to_cutline -dstalpha ' + kompress + ' "' + temp_input_raster + '" "' + temp_output_raster + '"'
            # Komandozeile an System senden
            os.system(string)
            # Speicherdialog aufrufen
            dlg = QFileDialog()
            initFilter = ''
            if temp_input_raster[:3]=='jpg':
                initFilter = 'Jpeg mit World (*.jpg)'
            elif temp_input_raster[:3]=='tif':
                initFilter = 'GeoTif (*.tif)'

            output_file = dlg.getSaveFileName(None, "Speicherpfad", input,
                                                      "GeoTif (*.tif);;Jpeg mit World (*.jpg);;Alle (*.*)",initialFilter=initFilter)
            # Ausgewähltes Ausgabeformat auswerten
            if output_file[1] == 'GeoTif (*.tif)':
                s = os.path.splitext(output_file[0])[0]
                # temp. geschnittenes Bild unter neuen Namen speichern
                fileFunc().file_copy(temp_output_raster, s + '.tif')
                # Bild als neuen Layer einfügen
                iface.addRasterLayer(s + '.tif', os.path.basename(output_file[0])[:-4])

            elif output_file[1] == 'Jpeg mit World (*.jpg)':
                s = os.path.splitext(output_file[0])[0]
                temp_input_raster = temp_output_raster
                temp_output_raster_transl = s + '.jpg'
                # Gdal Komandozeile zusammensetzen umwandlung zu Jpeg
                string = r'gdal_translate -of Jpeg -co worldfile=yes -mask 4 "' + temp_input_raster + '" "' + temp_output_raster_transl + '"'
                # Komandozeile an System senden
                os.system(string)
                # Bild als neuen Layer einfügen
                rasterlayer = iface.addRasterLayer(s + '.jpg', os.path.basename(output_file[0])[:-4])
                # Layer Koordinatensystem setzen
                rasterlayer.setCrs(QgsCoordinateReferenceSystem(outputsrs))
        except Exception as e:
            QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)
            # temp. geschnittenes Bild löschen
            fileFunc().file_del(temp_output_raster)
        finally:
            QgsMessageLog.logMessage('datei löschen', 'T2G Archäologie', Qgis.Info)
            # temp. geschnittenes Bild löschen
            fileFunc().file_del(temp_output_raster)

        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle('Frage')
        box.setText('Ausgangsdatei löschen?')
        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText('Datei und Layer')
        buttonY.setToolTip('Löscht Datei und Layer')
        buttonN = box.button(QMessageBox.No)
        buttonN.setText('Layer')
        buttonN.setToolTip('Löscht nur denn Layer')
        buttonA = box.button(QMessageBox.Abort)
        buttonA.setText('Behalten')
        buttonA.setToolTip('Löscht keins von beiden')
        buttonA.setFocus()
        box.exec_()

        if box.clickedButton() == buttonY:
            QgsProject.instance().removeMapLayer(layer.id())
            a = 0
            for layer in QgsProject.instance().mapLayers().values():
                QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
                if input in layer.source():
                    a = a + 1
            if a == 0:
                fileFunc().file_del(input)
            else:
                iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                               u"Datei ist mehrfach als Layer eingefügt und kann nicht gelöscht werden.",
                                               level=Qgis.Critical)
        elif box.clickedButton() == buttonN:
            QgsProject.instance().removeMapLayer(layer.id())
            pass
        elif box.clickedButton() == buttonA:
            pass


    def gtiff2jpg(self):
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.RasterLayer and layer.source()[-3:] == 'tif':
            #self.file2temp()
            input = os.path.abspath(str(unicode(layer.source())))
            outputsrs = layer.crs().authid()
            QgsMessageLog.logMessage(input, 'T2G Archäologie', Qgis.Info)

            try:
                layername = layer.name()
                input = str(unicode(layer.source()))

                inputtemp = input #r'C:/temp/#T2G-Arch#/temp.tif'
                outputtemp = os.path.splitext(input)[0] + '_transf' + os.path.splitext(input)[1]#r'C:/temp/#T2G-Arch#/temp_transf.jpg'

                string = r"gdal_translate -of JPEG -scale -co worldfile=yes " + '"' + inputtemp + '" "' + outputtemp + '"'
                os.system(string)

                output_file = QFileDialog.getSaveFileName(None, 'Speicherpfad',
                                                          os.path.splitext(input)[0],
                                                          'Jpeg mit World (*.jpg);;Alle (*.*)')
                if output_file[0] != '':
                    fileFunc().file_copy(outputtemp, output_file[0][:-4] + '.jpg')
                    fileFunc().file_copy(outputtemp[:-4]+'.wld', output_file[0][:-4] + '.wld')

                    rasterlayer = iface.addRasterLayer(output_file[0][:-4] + '.jpg', os.path.basename(output_file[0])[:-4])
                    rasterlayer.setCrs(QgsCoordinateReferenceSystem(outputsrs))

                    box = QMessageBox()
                    box.setIcon(QMessageBox.Question)
                    box.setWindowTitle('Frage')
                    box.setText('Datei löschen?')
                    box.setStandardButtons(QMessageBox.Yes | QMessageBox.No |QMessageBox.Abort)
                    buttonY = box.button(QMessageBox.Yes)
                    buttonY.setText('GeoTIF')
                    buttonY.setToolTip('Löscht GeoTiff und Layer')
                    buttonN = box.button(QMessageBox.No)
                    buttonN.setText('Layer')
                    buttonN.setToolTip('Löscht denn Layer')
                    buttonA = box.button(QMessageBox.Abort)
                    buttonA.setText('Behalten')
                    buttonA.setToolTip('Löscht keins von beiden')
                    buttonA.setFocus()
                    box.exec_()

                    if box.clickedButton() == buttonY:
                        QgsProject.instance().removeMapLayer(layer.id())
                        a=0
                        for layer in QgsProject.instance().mapLayers().values():
                            QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
                            if input in layer.source():
                                a=a+1
                        if a == 0:
                            fileFunc().file_del(input)
                            fileFunc().file_del(input[:-4] + '.wld')
                        else:
                            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                                       u"Datei ist mehrfach als Layer eingefügt und kann nicht gelöscht werden.",
                                                       level=Qgis.Critical)
                    elif box.clickedButton() == buttonN:
                        QgsProject.instance().removeMapLayer(layer.id())

                    elif box.clickedButton() == buttonA:
                        pass

            except Exception as e:
                QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)
            finally:
                fileFunc().file_del(outputtemp)
                fileFunc().file_del(outputtemp[:-4] + '.wld')
                fileFunc().file_del(outputtemp[:-4] + '.tif.aux.xml')
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                           u"Layer ist kein Rasterlayer oder eine GeoTif!",
                                           level=Qgis.Critical)


    def eventEditingStarted(self):
        #QgsMessageLog.logMessage('Änderung Start', 'T2G Archäologie', Qgis.Info)
        #self.valueTemp1 = int(getCustomProjectVariable('nextBefNr'))
        #setCustomProjectVariable('maxWerteAktualisieren', 'False')
        QgsMessageLog.logMessage('Beginne Änderung', 'T2G Archäologie', Qgis.Info)
        self.__lastMaxNumber = []
        self.__lastMaxNumber.append(self.dockwidget.txtNextBef.text())
        self.__lastMaxNumber.append(self.dockwidget.txtNextFund.text())
        self.__lastMaxNumber.append(self.dockwidget.txtNextProf.text())
        self.__lastMaxNumber.append(self.dockwidget.txtNextProb.text())
        pass

    def eventeFatureAdded(self, fid):
        QgsMessageLog.logMessage(str(fid) + 'Geometrie+neu', 'T2G Archäologie', Qgis.Info)

    def __eventFeaturesDeleted(self, fid):
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        self.getMaxValues()
        setCustomProjectVariable('maxWerteAktualisieren', 'False')
        self.iface.mapCanvas().refreshAllLayers()
        pass

    def __eventAttributeValueChanged(self,fid,idx,value):
        lay = self.iface.activeLayer()
        QgsMessageLog.logMessage('Wert Änderung', 'T2G Archäologie', Qgis.Info)
        try:
            field = lay.fields()[idx]
            QgsMessageLog.logMessage(str(fid) + ' ' + str(field.name()) + ' ' + str(value), 'T2G Archäologie',
                                     Qgis.Info)
        except IndexError:
            #return
            pass

        if isNumber(str(value)):
            if field.name() == "bef_nr":
                if  int(value) >= int(self.__lastMaxNumber [0]):
                    self.dockwidget.txtNextBef.setText(str(int(value) + 1))
                else:
                    self.dockwidget.txtNextBef.setText(str(self.__lastMaxNumber[0]))
            elif field.name() == "fund_nr":
                if int(value) >= int(self.__lastMaxNumber[1]):
                    self.dockwidget.txtNextFund.setText(str(int(value) + 1))
                else:
                    self.dockwidget.txtNextFund.setText(str(self.__lastMaxNumber[1]))
            elif field.name() == "prof_nr":
                if int(value) >= int(self.__lastMaxNumber[2]):
                    self.dockwidget.txtNextProf.setText(str(int(value) + 1))
                else:
                    self.dockwidget.txtNextProf.setText(str(self.__lastMaxNumber[2]))
            elif field.name() == "prob_nr":
                if int(value) >= int(self.__lastMaxNumber[3]):
                    self.dockwidget.txtNextProb.setText(str(int(value) + 1))
                else:
                    self.dockwidget.txtNextProb.setText(str(self.__lastMaxNumber[3]))
        else:
            pass
            #iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Nächste freihe Nummer konnte nicht ermittelt werden.",
            #                               level=Qgis.Critical)


    def currentLayerChanged(self):
        setCustomProjectVariable('obj_type', '')
        setCustomProjectVariable('obj_art', '')
        setCustomProjectVariable('schnitt_nr', '')
        setCustomProjectVariable('bef_nr', '')
        setCustomProjectVariable('planum', '')
        setCustomProjectVariable('fund_nr', '')
        setCustomProjectVariable('prob_nr', '')
        setCustomProjectVariable('prof_nr', '')
        setCustomProjectVariable('material', '')
        setCustomProjectVariable('ptnr', '')
        setCustomProjectVariable('autoAttribute', 'False')
        setCustomProjectVariable('autoZahl', 'False')
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        setCustomProjectVariable('SignalGeometrieNeu', 'False')

    def pointExp(self):
        # Exportpfad aus Configfile setzen
        exportpfad = self.config.getValue("Punkte Export","pfad Exportordner",'./../Jobs')

        self.toolButton1.setDefaultAction(self.action5)
        layer = iface.activeLayer()

        if layer.selectedFeatureCount() == 0 or layer.geometryType() != QgsWkbTypes.PointGeometry:
            QMessageBox.critical(None, "Meldung", u"Es sind keine Punkte selektiert oder es ist kein Punktlayer ausgewählt!", QMessageBox.Abort)
        else:
            output_file = QFileDialog.getSaveFileName(None, 'Speicherpfad',
                                                      QgsProject.instance().readPath(exportpfad),
                                                      'Text (*.txt);;Excel (*.csv);;Alle Dateien (*.*)')
            if output_file[0] != '':
                output_file = open(output_file[0], 'w')

                feats = []

                for feat in layer.selectedFeatures():
                    pt = (feat.geometry().asWkt()).split(" ", 1)[1]
                    coord = pt.split(" ")
                    x = round(float((coord[0]).replace("(", "")), 3)
                    y = round(float((coord[1])), 3)
                    z = round(float((coord[2]).replace(")", "")), 3)
                    msgout = '%s, %s, %s, %s\n' % (feat["ptnr"], x, y, z)
                    feats.append(msgout)

                box = QMessageBox()
                box.setIcon(QMessageBox.Question)
                box.setWindowTitle('Frage')
                box.setText('Wie soll sortiert werden?')
                box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                buttonY = box.button(QMessageBox.Yes)
                buttonY.setText('Punkt Nr')
                buttonN = box.button(QMessageBox.No)
                buttonN.setText('Datum')
                box.exec_()

                if box.clickedButton() == buttonY:
                    s_feats = sorted(feats, key=operator.itemgetter(0))
                elif box.clickedButton() == buttonN:
                    s_feats = sorted(feats, key=operator.itemgetter(1))

                #write to csv
                for item in s_feats:
                    output_file.write(item.replace(' ', ''))
                output_file.close()
                QMessageBox.information(None, "Meldung", u"Fertig!")

    def pointImp(self):
        # Importpfad aus Configfile setzen
        importpfad = self.config.getValue("Punkte Import","pfad Importordner",'./../Jobs')

        self.toolButton1.setDefaultAction(self.action4)
        layer = QgsProject.instance().mapLayersByName('E_Point')[0]
        result = QMessageBox.information(None, 'WICHTIG',
                                         'Dateiformat' + '\n' + 'ptnr  x  y  z' + '\n' + 'Möchten Sie fortfahren?            ',
                                         QMessageBox.Ok | QMessageBox.Cancel)
        layer = QgsProject.instance().mapLayersByName('E_Point')[0]
        if result == QMessageBox.Ok:

            input_file = QFileDialog.getOpenFileName(None, 'Quellpfad',
                                                     QgsProject.instance().readPath(importpfad),
                                                     'Vermessung (*.txt);;Text mit Komma (*.txt);;Text mit Tab (*.txt);;Excel (*.csv);;Alle Dateien (*.*)')

            dateiErw = os.path.splitext(input_file [0])[-1].lower()
            #try:
            if input_file[0] != '':
                progress = progressBar('Fortschritt')
                QCoreApplication.processEvents()
                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'maxWerteAktualisieren', 'False')
                lineid = 0
                objCount = 0
                if dateiErw == '.csv':
                    file = open(input_file[0])
                    linecount = fileLineCount(input_file[0])
                    progress.setText(str(linecount)+' Punkte werden importiert')
                    progress.setMaximum(linecount)
                    for line in file:
                        progress.setValue(lineid)
                        line = [string.strip() for string in line.splitlines()]
                        QgsMessageLog.logMessage(('Punkt importiert'), 'T2G Archäologie', Qgis.Info)
                        a = str(line).split(',')[0].lstrip()
                        b = str(line).split(',')[1].lstrip()
                        c = str(line).split(',')[2].lstrip()
                        d = str(line).split(',')[3].lstrip()
                        pt = QgsPoint(float(b), float(c), float(d))
                        attL = {'ptnr': a}
                        addPoint3D(layer, pt, attL)
                        lineid = lineid + 1
                    file.close()
                elif dateiErw == '.txt':
                    file = open(input_file[0])
                    lines = file.readlines()
                    file.close()
                    linecount = len(lines) #fileLineCount(input_file[0]) #
                    progress.setText(str(linecount) + ' Punkte werden importiert')
                    progress.setMaximum(linecount)

                    if 'Komma' in input_file [1]:
                        sep = ","
                    if 'Tab' in input_file [1]:
                        sep = "\t"
                    if 'Vermessung' in input_file [1]:
                        sep = "V"

                    for line in lines:
                        progress.setValue(lineid)
                        #if "." in line.split(sep)[1].lstrip():
                        if sep != 'V':
                            try:
                                #if len(line.split(sep)) > 1:
                                if "." in line:
                                    a = str(line).split(sep)[0].lstrip()
                                    b = str(line).split(sep)[1].lstrip()
                                    c = str(line).split(sep)[2].lstrip()
                                    d = str(line).split(sep)[3].lstrip()
                                else:
                                    continue
                            except:
                                iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Fehler! Falscher Spaltentrenner oder vorhandene Kopfzeile.", level=Qgis.Critical)
                                return
                        else:
                            a = str(line)[0:15].lstrip()
                            b = str(line)[16:32].lstrip()
                            c = str(line)[33:44].lstrip()
                            d = str(line)[45:53].lstrip()
                        pt = QgsPoint(float(b), float(c), float(d))
                        attL = {'ptnr': a}
                        addPoint3D(layer, pt, attL)
                        objCount = objCount + 1
                        lineid = lineid + 1
                    file.close()
                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'maxWerteAktualisieren', 'True')
                if  objCount>0:
                    iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Punkte eingetragen.", level=Qgis.Info)
                else:
                    iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Keine Punkte eingetragen.", level=Qgis.Critical)


    def profEntzpointExp(self):
        # Exportpfad aus Configfile setzen
        exportpfad = self.config.getValue("Profilentzerrung","pfad Exportordner")
        FN_PROFILNUMMER = self.config.getValue("Profilentzerrung","feldNProfNr")
        FN_DEF_FOTOENTZERRPUNKT = self.config.getValue("Profilentzerrung","feldNFEP")
        AW_FOTOENTZERRPUNKT = self.config.getValue("Profilentzerrung","attFEP")
        #FN_PROFILNUMMER = 'prof_nr'  # Feldname in der die Profilnummer steht
        #FN_DEF_FOTOENTZERRPUNKT = 'obj_type'  # Feldname in der die Entzerrpunkt-definition steht
        #AW_FOTOENTZERRPUNKT = 'Fotoentzerrpunkt'  # Entzerrpunkt-definition

        self.toolButton1.setDefaultAction(self.action6)
        profnr, ok = QInputDialog.getText(None, 'Profil', 'Profilnummer eingeben')
        if ok != True:
            return

        # Linien-Layer für Profillinie aussuchen
        profLayer = QgsProject.instance().mapLayersByName('E_Line')[0]
        suchstr = '"' + FN_PROFILNUMMER + '"=' + '\'' + profnr + '\''
        it = profLayer.getFeatures(QgsFeatureRequest(QgsExpression(suchstr)))
        ids = [i.id() for i in it]
        profLayer.selectByIds(ids)

        if str(profLayer.selectedFeatureCount()) == '0':
            QMessageBox.information(None, "Meldung", u"Kein Profil gefunden!")
            return
        elif profLayer.selectedFeatureCount() > 1:
            QMessageBox.information(None, "Meldung",
                                    str(profLayer.selectedFeatureCount()) + u" Profile gefunden! Abbruch")
            return

        ### Anfang Blickrichtung bestimmen
        view = None
        koordlist = []
        for feat in profLayer.selectedFeatures():
            if feat.geometry().isMultipart():
                # Multipart
                parts = feat.geometry().asGeometryCollection()
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({'x': vertex.x(), 'y': vertex.y()})
                QgsMessageLog.logMessage(str(koordlist[0]['x']), 'T2G Archäologie', Qgis.Info)
                pointAx = koordlist[0]['x']
                pointAy = koordlist[0]['y']
                pointBx = koordlist[-0]['x']
                pointBy = koordlist[-0]['y']
            else:
                # Singlepart
                pointA = feat.geometry().get()[0]
                pointB = feat.geometry().get()[-1]
                pointAx = pointA.x()
                pointAy = pointA.y()
                pointBx = pointB.x()
                pointBy = pointB.y()

            dx = pointBx - pointAx
            dy = pointBy - pointAy
            vp = [dx, dy]
            v0 = [-1, 1]
            # Lösung von hier: https://stackoverflow.com/questions/14066933/direct-way-of-computing-clockwise-angle-between-2-vectors/16544330#16544330, angepasst auf Berechnung ohne numpy
            dot = v0[0] * vp[0] + v0[1] * vp[1]  # dot product: x1*x2 + y1*y2
            det = v0[0] * vp[1] - vp[0] * v0[1]  # determinant: x1*y2 - y1*x2

            radians = math.atan2(det, dot)
            angle = math.degrees(radians)
            # negative Winkelwerte (3. und 4. Quadrant, Laufrichtung entgegen Uhrzeigersinn) in fortlaufenden Wert (181 bis 360) umrechnen
            if angle < 0:
                angle *= -1
                angle = 180 - angle + 180

            if angle <= 90:
                view = "N"
            elif angle <= 180:
                view = "W"
            elif angle <= 270:
                view = "S"
            elif angle > 270:
                view = "E"
        ### Ende Blickrichtung bestimmen

        feats = []
        ok = True
        profPointLayer = QgsProject.instance().mapLayersByName('E_Point')[0]
        # such2 = '"obj_art"=\'Fotoentzerrpunkt\' and '
        # such2 = '"obj_type"=\'V_Referenzierungspunkt\' and '
        # such2 = '"obj_type"='+ '\''+ AW_FOTOENTZERRPUNKT + '\' and '
        such2 = '"' + FN_DEF_FOTOENTZERRPUNKT + '"=' + '\'' + AW_FOTOENTZERRPUNKT + '\' and '
        it = profPointLayer.getFeatures(QgsFeatureRequest(QgsExpression(str(such2 + suchstr))))
        QgsMessageLog.logMessage(str(such2 + suchstr), 'T2G Archäologie', Qgis.Info)
        ids = [i.id() for i in it]
        profPointLayer.selectByIds(ids)
        if profPointLayer.selectedFeatureCount() == 0:
            QMessageBox.information(None, "Meldung", u"Keine Profilentzerrpunkte gefunden!")
            return
        # QgsMessageLog.logMessage('aaa ' + len(geom.featureCount()), 'T2G Archäologie', Qgis.Info)

        #######
        msgout = '%s, %s, %s, %s, %s, %s, %s\n' % ('punktnr', 'x', 'y', 'z', 'profnr', 'view', 'pointsused')
        feats.append(msgout)
        for feat in profPointLayer.selectedFeatures():
            koordlist = []
            if feat.geometry().isMultipart():
                # Multipart
                parts = feat.geometry().asGeometryCollection()
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({'x': vertex.x(), 'y': vertex.y(), 'z': vertex.z()})
                        QgsMessageLog.logMessage(str(vertex.z()), 'T2G Archäologie', Qgis.Info)
                x = koordlist[0]['x']
                y = koordlist[0]['y']
                z = koordlist[0]['z']
            else:
                # Singlepart
                x = feat.geometry().get().x()  # round(float((coord[0]).replace("(", "")), 3)
                y = feat.geometry().get().y()  # round(float((coord[1])), 3)
                z = feat.geometry().get().z()  # round(float((coord[2]).replace(")", "")), 3)
                value = '---'
            try:
                value = str(feat["aktcode"]) + '_' + str(feat["ptnr"])  # Fehler
            except Exception as e:
                QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)
                pass
            ###
            msgout = '%s, %s, %s, %s, %s, %s, %s\n' % (value, x, y, z, profnr, view, 1)
            # if feat["obj_type"] != 'Fotoentzerrpunkt' or feat["prof_nr"] == '':
            if feat[FN_DEF_FOTOENTZERRPUNKT] != AW_FOTOENTZERRPUNKT or feat[FN_PROFILNUMMER] == '':
                ok = False
            feats.append(msgout)
        delLayer("Prof Entzerrpunkte AAR-Tool")
        box = QMessageBox()
        if ok == False:
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Frage')
            box.setText('Manche Punkte Sind keine Profilentzerrpunkte!')
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('OK')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('Abbruch')
            box.exec_()
            if box.clickedButton() == buttonY:
                ok = True
            elif box.clickedButton() == buttonN:
                ok = False

        if ok == True:
            box = QMessageBox()
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Frage')
            box.setText('Export als ...?')
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('Templayer')
            buttonY.setToolTip('Erzeugt einen temporären Layer.')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('CSV-Datei')
            buttonN.setToolTip('Erzeugt eine CSV Datei.')
            buttonA = box.button(QMessageBox.Abort)
            buttonA.setText('Beides')
            buttonA.setToolTip('Erzeugt einen temporären Layer und eine CSV-Datei.')
            buttonY.setFocus()
            box.exec_()

            if box.clickedButton() == buttonN or box.clickedButton() == buttonA:
                # csv-Datei
                output_file = QFileDialog.getSaveFileName(None, 'Speicherpfad',
                                                          QgsProject.instance().readPath(exportpfad),
                                                          'Excel (*.csv);;Excel (*.txt);;Alle Dateien (*.*)')
                if output_file[0] != '':
                    # write to csv
                    output_file = open(output_file[0], 'w')
                    for item in feats:
                        output_file.write(item.replace(' ', ''))
                    output_file.close()
            vl = None
            if box.clickedButton() == buttonY or box.clickedButton() == buttonA:
                # templayer erzeugen
                vl = QgsVectorLayer("Point", "Prof Entzerrpunkte AAR-Tool", "memory")
                # change memorylayer crs to layer crs
                vl.setCrs(profPointLayer.crs())
                pr = vl.dataProvider()
                pr.addAttributes([QgsField("punktnr", QVariant.String, 'text'),
                                  QgsField("x", QVariant.Double, 'double'),
                                  QgsField("y", QVariant.Double, 'double'),
                                  QgsField("z", QVariant.Double, 'double'),
                                  QgsField("profilnr", QVariant.Int, 'integer'),
                                  QgsField("view", QVariant.String, 'text'),
                                  QgsField("points used", QVariant.Int, 'integer')])
                vl.updateFields()
                feat = QgsFeature()
                for item in feats:
                    it = item.split(',')
                    point = QgsPoint(float(it[1]), float(it[2]), float(it[3]))
                    feat.setGeometry(QgsGeometry(point))
                    feat.setAttributes(
                        [str(it[0]), point.x(), point.y(), point.z(), int(it[4]), str(it[5]), int(it[6])])
                    pr.addFeatures([feat])
                    # QgsMessageLog.logMessage(str(it[1]), 'T2G Archäologie', Qgis.Info)
                # add memorylayer to canvas
                QgsProject.instance().addMapLayer(vl, False)
                root = QgsProject.instance().layerTreeRoot()
                g = root.findGroup('Vermessung')
                g.insertChildNode(0, QgsLayerTreeLayer(vl))
            delSelectFeature()
            #my_plugin = plugins.get('profileAAR')
            #my_plugin.run()


    def getMaxValues(self):
        if getCustomProjectVariable('maxWerteAktualisieren') == 'True':
            #return
            layerLine = QgsProject.instance().mapLayersByName('E_Line')[0]
            layerPoly = QgsProject.instance().mapLayersByName('E_Polygon')[0]
            layerPoint = QgsProject.instance().mapLayersByName('E_Point')[0]
            layerlist = [layerLine, layerPoly, layerPoint]

            BefNrMax = 0
            FundNrMax = 0
            ProfNrMax = 0
            ProbNrMax = 0

            for layer in layerlist:
                if len([feat["bef_nr"] for feat in layer.getFeatures()]) > 0:
                    max1 = maxValue(layer, 'bef_nr')
                    #QgsMessageLog.logMessage(str(max1), 'T2G Archäologie', Qgis.Info)
                    if BefNrMax < max1:
                        BefNrMax = max1
                if len([feat["fund_nr"] for feat in layer.getFeatures()]) > 0:
                    max2 = maxValue(layer, 'fund_nr')
                    if FundNrMax < max2:
                        FundNrMax = max2
                try:
                    if len([feat["prob_nr"] for feat in layer.getFeatures()]) > 0:
                        max3 = maxValue(layer, 'prob_nr')
                        if ProbNrMax < max3:
                            ProbNrMax = max3
                except Exception as e:
                    QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)

                try:
                    if len([feat["prof_nr"] for feat in layer.getFeatures()]) > 0:
                        max4 = maxValue(layer, 'prof_nr')
                        if ProfNrMax < max4:
                            ProfNrMax = max4
                except Exception as e:
                    QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)

                self.dockwidget.txtNextBef.setText(str(BefNrMax + 1))
                self.dockwidget.txtNextFund.setText(str(FundNrMax + 1))
                self.dockwidget.txtNextProf.setText(str(ProfNrMax + 1))
                self.dockwidget.txtNextProb.setText(str(ProbNrMax + 1))

                setCustomProjectVariable('nextBefNr', str(BefNrMax + 1))
                setCustomProjectVariable('nextProfNr', str(ProfNrMax + 1))
                setCustomProjectVariable('nextFundNr', str(FundNrMax + 1))
                setCustomProjectVariable('nextProbNr', str(ProbNrMax + 1))

            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Nächste zu vergebende Nummern wurden aktuallisiert.", level=Qgis.Info)
            setCustomProjectVariable('maxWerteAktualisieren', 'False')
            #self.autoNummer()

    def ObjNumberToList(self):
        self.dockwidget.treeWidget.clear()
        itemlist = ['Befunde', 'Funde', 'Profile', 'Proben']
        fieldnamelist = ['bef_nr', 'fund_nr', 'prof_nr', 'prob_nr']

        layerLine = QgsProject.instance().mapLayersByName('E_Line')[0]
        layerPoly = QgsProject.instance().mapLayersByName('E_Polygon')[0]
        layerPoint = QgsProject.instance().mapLayersByName('E_Point')[0]
        layerlist = [layerLine, layerPoly, layerPoint]

        a = 0

        for fieldname in fieldnamelist:
            a = a + 1
            list = []
            l = 0
            for layer in layerlist:
                l=l+1
                for field in layer.fields():
                    if field.name() == fieldname:
                        #QgsMessageLog.logMessage(str(fieldname), 'T2G Archäologie', Qgis.Info)
                        idField = layer.dataProvider().fieldNameIndex(fieldname)
                        for feat in layer.getFeatures():
                            attrs = feat.attributes()
                            if attrs[idField] != None:
                                try:
                                    val = str(attrs[idField] + '|' + layer.name())
                                    list.append(val)
                                    #QgsMessageLog.logMessage(str(val), 'T2G Archäologie', Qgis.Info)
                                except ValueError:
                                    pass
                try:
                    pass
                except ValueError:
                    list.append(0)
            list.sort()

            item = QTreeWidgetItem([itemlist[a-1]])
            for obj in list:
                obj = obj.split('|')
                item.addChild(QTreeWidgetItem([str(obj[0]),str(obj[1])]))

            self.dockwidget.treeWidget.addTopLevelItem(item)

        self.dockwidget.treeWidget.setSortingEnabled(True)
        self.dockwidget.treeWidget.sortByColumn(0,Qt.AscendingOrder)

    def ozoom_1_ok(self):
        #layer = QgsProject.instance().mapLayer(self.dockwidget.cbo_ozoom_1.currentLayer().id())
        layer = iface.activeLayer()
        layerLine = QgsProject.instance().mapLayersByName('E_Line')[0]
        layerPoly = QgsProject.instance().mapLayersByName('E_Polygon')[0]
        layerPoint = QgsProject.instance().mapLayersByName('E_Point')[0]
        layerlist = [layerLine, layerPoly, layerPoint]
        labellist = [self.dockwidget.labE_Line, self.dockwidget.labE_Poly, self.dockwidget.labE_Poi]
        layer.removeSelection()
        suchstr, ok = QInputDialog.getText(None,'Suchen','Nummer eingeben')
        if ok:
            if self.dockwidget.cboSuche.currentText() == 'Befund':
                fieldName = 'bef_nr'
            if  self.dockwidget.cboSuche.currentText() == 'Fund':
                fieldName = 'fund_nr'
            if  self.dockwidget.cboSuche.currentText() == 'Profil':
                fieldName = 'prof_nr'
            if  self.dockwidget.cboSuche.currentText() == 'Probe':
                fieldName = 'prob_nr'
            if suchstr[0] == '':
                return
            if isNumber(suchstr[0]):
                suchstr = fieldName + '=' + suchstr
            else:
                suchstr = fieldName + '=' + '\'' + suchstr + '\''
        else:
            return
        expr = QgsExpression(suchstr)#QgsExpression("befNr='120'")
        a = 0
        meldung = True
        for layer in layerlist:
            a = a + 1
            QgsMessageLog.logMessage(str(suchstr), 'T2G Archäologie', Qgis.Info)
            it = layer.getFeatures(QgsFeatureRequest(expr))
            ids = [i.id() for i in it]
            layer.selectByIds(ids)
            #self.dockwidget.lab_oselc_1.setText (str(layer.selectedFeatureCount()))

            if layer.selectedFeatureCount() > 0:
                self.iface.mapCanvas().zoomToSelected(layer)
                if not layer.geometryType() == QgsWkbTypes.PointGeometry:
                    self.iface.mapCanvas().zoomByFactor(5)
                self.iface.mapCanvas().refresh()
                labellist[a-1].setText(str(layer.selectedFeatureCount()))
                meldung = False
            else:
                labellist[a - 1].setText(str(layer.selectedFeatureCount()))
                if meldung != False:
                    meldung = True
        if meldung == True:
            QMessageBox.warning(None, "Meldung", 'Keine Objekte gefunden!')

    def lineFeatureReverse(self):
        self.toolButton2.setDefaultAction(self.action7)
        layer = self.iface.mapCanvas().currentLayer()
        if layer.geometryType() != QgsWkbTypes.LineGeometry:
            QMessageBox.information(None, 'WICHTIG', 'Falscher Geometrietyp!', QMessageBox.Cancel)
            return
        if layer.selectedFeatures() == []:
            QMessageBox.information(None, 'WICHTIG','Keine Geometrie gewählt!', QMessageBox.Cancel)
            return
        layer.startEditing()
        for feature in layer.selectedFeatures():
            geom = feature.geometry()
            if geom.isMultipart():
                mls = QgsMultiLineString()
                for line in geom.asGeometryCollection():
                    mls.addGeometry(line.constGet().reversed())
                newgeom = QgsGeometry(mls)
                layer.changeGeometry(feature.id(), newgeom)
            else:
                newgeom = QgsGeometry(geom.constGet().reversed())
                layer.changeGeometry(feature.id(), newgeom)

        layer.endEditCommand()
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
        iface.messageBar().pushMessage(u"Linienrichtung: ", u"gewechselt! Fertig.", level=Qgis.Info)

    def featureXMove(self):
        self.featureMove('x')
    def featureYMove(self):
        self.featureMove('y')
    def featureZMove(self):
        self.featureMove('z')

    def featureMove(self, koord):
        layer = iface.activeLayer()
        if len(layer.selectedFeatures()) == 0:
            QMessageBox.critical(None, "Meldung",
                                 u"Keine Objekte gewält!",
                                 QMessageBox.Ok)
            return
        dialog = QInputDialog()
        zvalue, ok = dialog.getText(None, 'Neuen ' + koord + '-Wert eingeben', '@ relativ, # absolut \n '
                                                                                     'keins von beiden -> absolut ',text='@', inputMethodHints=Qt.ImhNone)
        if ok:
            if layer.geometryType() != QgsWkbTypes.PointGeometry and (zvalue [0] == '#' or isNumber(zvalue) and koord != 'z'):
                QMessageBox.critical(None, "Meldung",
                                     u"Absolute Koordinaten(#) nur:\n "
                                     u"- bei Punktlayern im XYZ-Wert\n "
                                     u"- bei Linien- und Polygonlayern im Z-Wert möglich!",
                                     QMessageBox.Ok)
                return

            for feat in layer.selectedFeatures():
                QgsMessageLog.logMessage(str(feat.id()) + 'move', 'T2G Archäologie', Qgis.Info)
                inst = FeatureQuestionDockWidget(self.iface, layer, feat)

                k = 0
                for a in inst.koordList:
                    if zvalue[0] == '@':
                        inst.koordList[k][koord] = float(float(inst.koordList[k][koord]) + float(zvalue[1:]))
                    elif zvalue[0] == '#':
                        inst.koordList[k][koord] = float(zvalue[1:])
                    elif isNumber(zvalue):
                        inst.koordList[k][koord] = float(zvalue)
                    k = k + 1
                #inst.featureUpdate(layer,feat)
                inst.OK()
        else:
            delSelectFeature()

    def editLayerEncoding(self):

        for layer in QgsProject.instance().mapLayers().values():
            if layer.type() == QgsMapLayer.VectorLayer:
                layer.setProviderEncoding(u'UTF-8')
                layer.dataProvider().setEncoding(u'UTF-8')
                layer.dataProvider().capabilities()
                #QMessageBox.information(None, 'WICHTIG', str(layer.source()), QMessageBox.Cancel)

    def delAllFeature(self):
        result = QMessageBox.warning(None, "Achtung",
                             u"Wollen Sie wirklich alle Objekte\n "
                             u"auf den Eingabelayern löschen?",
                             QMessageBox.Ok,QMessageBox.Abort)
        if result == QMessageBox.Ok:
            list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
            for layer in list:

                #layer =  QgsProject.instance().mapLayersByName(layername)[0]
                layer.startEditing()
                QgsMessageLog.logMessage('Alle Objekte auf Layer ' + layer.name() + ' gelöscht.', 'T2G Archäologie', Qgis.Info)
                listOfIds = [feat.id() for feat in layer.getFeatures()]
                layer.deleteFeatures(listOfIds)
                layer.commitChanges()
        else:
            QgsMessageLog.logMessage('Abbruch', 'T2G Archäologie', Qgis.Info)
        pass


    def FilterGesetzt(self):
        #QgsMessageLog.logMessage('filter gesetzt', 'T2G Archäologie', Qgis.Info)
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in list:
            #QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
            if 'subset' in layer.source():
                self.dockwidget.txtNextBef.setText('xxxxx')
                self.dockwidget.txtNextFund.setText('xxxxx')
                self.dockwidget.txtNextProf.setText('xxxxx')
                self.dockwidget.txtNextProb.setText('xxxxx')
                #QgsMessageLog.logMessage('Filter gesetzt', 'T2G Archäologie', Qgis.Info)
        pass

    def eventAllLayfFilterEnt(self):
        for layer in QgsProject.instance().mapLayers().values():
            self.setLayerFilter('')
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        self.getMaxValues()

    def eventAllLayFilter(self):
        query, ok = QInputDialog().getText(None, 'Abfrage eingeben', '')
        if ok:
            self.setLayerFilter(query)
        else:
            self.eventAllLayfFilterEnt()

    def eventAllLayBefFilter(self):
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in list:
            layer.commitChanges()
        value, ok = QInputDialog().getText(None, 'Such Befund Nr eingeben', '')
        if ok:
            query = '"bef_nr" LIKE \'' + value + ',%\'' + \
                    ' or "bef_nr" LIKE ' + '\'%,' + value + ',%\'' + \
                    ' or "bef_nr" LIKE \'%,' + value + '\'' + \
                    ' or "bef_nr" LIKE ' + '\'' + value + '\''
            self.setLayerFilter(query)
        else:
            self.eventAllLayfFilterEnt()
            pass

        setSelectAllFeatures(self.layerPoly)
        delSelectFeature()

    def setLayerFilter(self,query):
        for layer in QgsProject.instance().mapLayers().values():
            if 'Line.shp' in layer.source() or 'Polygon.shp' in layer.source() or 'Point.shp' in layer.source():
                #QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)

                #QgsMessageLog.logMessage(query, 'T2G Archäologie', Qgis.Info)
                layer.setSubsetString(query)

    def addProfil(self):
        #self.T2G = plugins.get('Tachy2GIS-3D_viewer')#Tachy2GIS-master
        if self.T2G.pluginIsActive==False:
            self.T2G.run()
        #my_plugin.exec_()
        #iface.showOptionsDialog()#.trigger()
        #for item in (plugins['Tachy2GIS-master'].iface.pluginMenu()).actions():
        #    QgsMessageLog.logMessage(str(item.text()), 'T2G Archäologie', Qgis.Info)
        #    if item.text() == '&Tachy2GIS':
        #        item.menu().actions()[0].activate(QAction.Trigger)
        #        break

    def myDlgDrucklayoutShow(self):
            dialog = dlgDrucklayout(self.iface)
            dialog.show()
    def myDlgGPStoShapeShow(self):
            dialog = dlgGPStoShape(self.iface)
            dialog.show()

    def myDlgAttributverwaltungShow(self):
        dialog = dlgAttributverwaltung(self.iface)
        dialog.show()

    def myDlgFeatureQuestionShow(self):
        #dialog = dlgFeatureQuestion(self.iface, self.selectedLayer, self.selectedFeature)
        iface.setActiveLayer(self.selectedLayer)
        self.dwFeatureQuestion = FeatureQuestionDockWidget(self.iface, self.selectedLayer, self.selectedFeature)
        self.dwFeatureQuestion.show()

    def myDlgAllLayerQuestionShow(self):
        #self.dwAllLayerQuestion = AllLayerQuestionDockWidget(self.iface)
        #self.dwAllLayerQuestion.show()
        pass

    def myDlgFeatureCheckShow(self):
        myDlgFeatureCheck = GeometryCheckDockWidget(self.iface,iface.mapCanvas())#mainWindow()
        myDlgFeatureCheck.setAutoFillBackground(True)
        myDlgFeatureCheck.show()

    def myDlgRasterLayerShow(self):
        self.toolButton3.setDefaultAction(self.action9)
        myDlgRasterLayerView = RasterLayerViewDockWidget(self.iface, iface.mapCanvas())  # mainWindow()
        myDlgRasterLayerView.setAutoFillBackground(True)
        myDlgRasterLayerView.show()

    def myDwgLookForMissingAttributesShow(self):
        self.dwLookForMissingAttributes = LookForMissingAttributesDockWidget(self.iface)#mainWindow()
        self.dwLookForMissingAttributes.show()
        self.dwLookForMissingAttributes.ui.cboFieldName.setCurrentText('bef_nr')

    def help(self):
        QMessageBox.information(None, 'Hilfe', os.path.join(self.ProjPfad, 'Hinweise.pdf'), QMessageBox.Cancel)
        subprocess.Popen(os.path.join(self.ProjPfad, 'Hinweise.pdf'),shell=True)

    def myDlgSettingsShow(self):
        myDlgSettingsView = DlgSettings(self, self.config)  # mainWindow()
        #myDlgSettingsView.setAutoFillBackground(True)
        myDlgSettingsView.show()
        pass

    def watchEvent(self):
        projectSaveFunc().shapesSave()
        origFileName = QgsProject.instance().fileName()
        if origFileName != "":      #and QgsProject.instance().isDirty()
            bakFileName = origFileName + ".bak"
            fileFunc().file_del(bakFileName)
            QgsProject.instance().write()
            QgsProject.instance().write(bakFileName )
            QgsProject.instance().setFileName(origFileName)

        if projectSaveFunc().project_save(unicode(self.ProjPfad)) == 'False':
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: Fehler!",
                                           level=Qgis.Critical)
            QgsMessageLog.logMessage("Auto Backup: Fehler!", 'T2G Archäologie', Qgis.Critical)
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: Erstellt!",
                                           level=Qgis.Info)
            QgsMessageLog.logMessage("Auto Backup: Erstellt.", 'T2G Archäologie', Qgis.Info)

        ziel = os.path.join(self.ProjPfad, r'_Sicherungen_')
        ordner = []

        for folder in next(os.walk(ziel))[1]:
            ordner.append((str(folder)))

        for i in range(0, len(ordner) - 5):
            fileFunc().directory_del(os.path.join(ziel, ordner[i]))


    def projectPfadExplorer(self):
        self.iface.actionSelectRectangle().trigger()
        subprocess.call(r'explorer "' + self.ProjPfad + '"')

    def dayProjectSave(self):
        self.toolButton.setDefaultAction(self.action2)
        projectSaveFunc().shapesSave()
        QgsProject.instance().write()
        if projectSaveFunc().dayproject_save(unicode(self.ProjPfad)) == 'False':
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Speicherung Tagesdatei: Fehler!",
                                           level=Qgis.Critical)
            QgsMessageLog.logMessage("Speicherung Tagesdatei: Fehler!", 'T2G Archäologie', Qgis.Critical)
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Speicherung Tagesdatei: Erfolgreich.",
                                           level=Qgis.Info)
            QgsMessageLog.logMessage("Speicherung Tagesdatei: Erfolgreich.", 'T2G Archäologie', Qgis.Info)

    def featureQuestion(self):
        self.iface.mapCanvas().setMapTool(self.mapTool)

    def editFeature(self,layer,feature):
        delSelectFeature()
        self.selectedLayer = layer
        self.selectedFeature = feature
        koordlist=[]
        z =[]
        contextMenu = QtWidgets.QMenu()
        if layer.type() == QgsMapLayer.RasterLayer:
            pass

        # multipart
        elif self.selectedFeature.geometry().isMultipart():
            parts = self.selectedFeature.geometry().asGeometryCollection()
            if self.selectedLayer.geometryType() == QgsWkbTypes.PointGeometry:
                for part in parts:
                    for vertex in part.vertices():
                        m = self.pointMaker
                        m.setMaker(vertex.x(),vertex.y())
                pass

            else:
                koordlist = []
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({0: vertex.x(), 1: vertex.y(),2: vertex.z()})
                        z.append(vertex.z())
                    r = self.rubberBand
                    r.setRubberBandPoly(koordlist,3)

            contextMenu.addAction('Z min:  ' + str(round(min(z), 2)))
            contextMenu.addAction('Z max:  ' + str(round(max(z), 2)))
        else:
        #singlepart
            if self.selectedLayer.geometryType() == QgsWkbTypes.PointGeometry:
                self.pointMaker.setMarker(self.selectedFeature.geometry().get().x(), self.selectedFeature.geometry().get().y(),12,2)
                contextMenu.addAction('X: ' + str(self.selectedFeature.geometry().get().x()))
                contextMenu.addAction('Y: ' + str(self.selectedFeature.geometry().get().y()))
                contextMenu.addAction('Z: ' + str(self.selectedFeature.geometry().get().z()))
            elif layer.geometryType() == QgsWkbTypes.LineGeometry:
                n = len(self.selectedFeature.geometry().asPolyline()[0])
                z = []
                koordlist =[]
                for i in range(n):
                    z.append(float(self.selectedFeature.geometry().vertexAt(i).z()))
                    koordlist.append({'x': self.selectedFeature.geometry().vertexAt(i).x(),
                                      'y': self.selectedFeature.geometry().vertexAt(i).y(),
                                      'z': self.selectedFeature.geometry().vertexAt(i).z()})
                self.rubberBand.setRubberBandPoly(koordlist,3)
                contextMenu.addAction('Z min:  ' + str(round(min(z), 2)))
                contextMenu.addAction('Z max:  ' + str(round(max(z), 2)))

                zmit = ((max(z) - min(z)) / 2) + round(min(z), 2)
                contextMenu.addAction('Z mit:  ' + str(round(zmit, 2)))
                contextMenu.addAction('Länge:  ' + str(round(self.selectedFeature.geometry().length(), 2)) + ' m')
            elif self.selectedLayer.geometryType() == QgsWkbTypes.PolygonGeometry:
                z = []
                n = self.selectedFeature.geometry().asPolygon()[0]
                for i in range(len(n)):
                    koordlist.append({'x': self.selectedFeature.geometry().vertexAt(i).x(),
                                      'y': self.selectedFeature.geometry().vertexAt(i).y(),
                                      'z': self.selectedFeature.geometry().vertexAt(i).z()})
                    z.append(float(self.selectedFeature.geometry().vertexAt(i).z()))
                self.rubberBand.setRubberBandPoly(koordlist,3)

                contextMenu.addAction('Z min:  ' + str(round(min(z), 2)))
                contextMenu.addAction('Z max:  ' + str(round(max(z), 2)))

                zmit = ((max(z) - min(z)) / 2) + round(min(z), 2)
                contextMenu.addAction('Z mit:  ' + str(round(zmit, 2)))
                contextMenu.addAction('Fläche:  ' + str(round(self.selectedFeature.geometry().area(), 2)) + ' m2')

        #contextMenu.setStyleSheet("QMenu { Background-color : rgb(217, 241, 255) ; color : rgb(20, 50, 255)}")
        contextMenu.addAction("Layername: " + str(layer.name()))
        dlgFeatureQuestionTableShow = contextMenu.addAction(
            QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons","Liste.bmp")), "Attributtabelle")
        dlgFeatureQuestionTableShow.triggered.connect(self.showAttributeTable)
        dlgFeatureQuestionShow = contextMenu.addAction(
            QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons", "Formular.jpg")), "Geometriedaten")
        dlgFeatureQuestionShow.triggered.connect(self.myDlgFeatureQuestionShow)
        #contextMenu.addSeparator()
        FeatureSelect = contextMenu.addAction(
            QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons","FeatureSelect.gif")), "Geometrie auswählen")
        FeatureSelect.triggered.connect(self.featureSelect)
        #FeatureSelectExit = contextMenu.addAction(
        #    QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons", "FeatureSelect.gif")), "Auswahl beenden.")
        #FeatureSelectExit.triggered.connect(self.featureSelectedExit)
        QgsMessageLog.logMessage(str(feature.id()), 'T2G Archäologie', Qgis.Info)
        contextMenu.addSeparator()


        attrs = self.selectedFeature.attributes()
        fields = self.selectedFeature.fields().toList()

        for i, attr in enumerate(attrs):
            name = fields[i].name()
            if str(attr) == 'NULL':
                attr = ''
            if name == 'aktcode':
                contextMenu.addAction('Grabung:  ' + str(attr))
            if name == 'obj_type':
                contextMenu.addAction('Objekttyp:  ' + str(attr))
            if name == 'obj_art':
                contextMenu.addAction('Objektart:  ' + str(attr))
            if name == 'schnitt_nr':
                contextMenu.addAction('Schnitt-Nr:  ' + str(attr))
            if name == 'bef_nr':
                contextMenu.addAction('Befund-Nr:  ' + str(attr))
            if name == 'fund_nr':
                contextMenu.addAction('Fund-Nr:  ' + str(attr))
            if name == 'prof_nr':
                contextMenu.addAction('Profil-Nr:  ' + str(attr))
            if name == 'planum':
                contextMenu.addAction('Planum:  ' + str(attr))
            if name == 'material':
                contextMenu.addAction('Material:  ' + str(attr))
            if name == 'geo-arch':
                contextMenu.addAction('geo/arch:  ' + str(attr))
            if name == 'ptnr':
                contextMenu.addAction('Punkt-Nr:  ' + str(attr))
        contextMenu.addAction('-----------------------')

        contextMenu.exec_(QtGui.QCursor.pos())
        self.rubberBand.rubberBandClean()
        self.pointMaker.makerClean()

    def featureSelect(self):
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))

    def showAttributeTable(self):
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))
        query = "id = " + str(int(self.selectedFeature.attributes()[0]))
        self.iface.showAttributeTable(self.selectedLayer,query)

    #def klickPointLabel(self):
    #    self.toolButton.setDefaultAction(self.action3)
    #    self.iface.mapCanvas().setMapTool(self.dockwidget.canvas_clicked)

    def befundLabel(self):
        if self.dockwidget.txtPointTemp.text()=='':
            return
        x = self.dockwidget.txtPointTemp.text().split(',')[0]#5469621.4550791355
        y = self.dockwidget.txtPointTemp.text().split(',')[1]#5708874.320934738
        z = 0
        layer = QgsProject.instance().mapLayersByName('E_Point')[0]
        befnr, ok = QInputDialog.getText(None, '', 'Befund Nr. eingeben')
        if ok:
            pt = QgsPoint(float(x), float(y), float(z))
            attL = {'obj_type': 'Kartenbeschriftung', 'obj_art': 'Befund', 'bef_nr': befnr}
            addPoint3D(layer, pt, attL)
        iface.mapCanvas().refreshAllLayers()
        self.iface.actionSelectRectangle().trigger()
        self.dockwidget.txtPointTemp.setText('')
#polygon clipping preview
    def insideClip(self): # inside
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.VectorLayer:
            if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                selection = layer.selectedFeatures()
                if len(selection) != 0:
                    fsel = selection[0]
                    # set layer editable
                    layer.startEditing()
                    for g in layer.getFeatures():
                        if g.id() != fsel.id():
                            if (g.geometry().intersects(fsel.geometry())):
                                # clipping non selected intersecting features
                                attributes = g.attributes()
                                diff = QgsFeature()
                                diff.setGeometry(g.geometry().difference(fsel.geometry()))
                                # copy attributes from original feature
                                diff.setAttributes(attributes)
                                # add modified feature to layer
                                layer.addFeature(diff)
                                # remove old feature
                                layer.deleteFeature(fsel.id())

                        # refresh the view and clear selection
                    self.iface.mapCanvas().refresh()
                    self.iface.mapCanvas().currentLayer().selectAll()
                    self.iface.mapCanvas().currentLayer().invertSelection()

    def outsideClip(self): # outside
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.VectorLayer:
            if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                selection = layer.selectedFeatures()
                if len(selection) != 0:
                    fsel = selection[0]
                    # set layer editable
                    layer.startEditing()
                    for g in layer.getFeatures():
                        if g.id() != fsel.id():
                            if (g.geometry().intersects(fsel.geometry())):
                                # clipping non selected intersecting features
                                attributes = g.attributes()
                                diff = QgsFeature()
                                diff.setGeometry(fsel.geometry().difference(g.geometry()))
                                # copy attributes from original feature
                                diff.setAttributes(attributes)
                                # add modified feature to layer
                                layer.addFeature(diff)
                                # remove old feature
                                layer.deleteFeature(fsel.id())

                        # refresh the view and clear selection
                    self.iface.mapCanvas().refresh()
                    self.iface.mapCanvas().currentLayer().selectAll()
                    self.iface.mapCanvas().currentLayer().invertSelection()

    def setAbbruch(self):
        self.abbruch = True
        iface.messageBar().clearWidgets()

    def createCancellationMessage(self, text):
        iface.messageBar().clearWidgets()
        widgetMessage = iface.messageBar().createMessage(text)
        button = QPushButton(widgetMessage)
        button.setText("Abbruch")
        button.pressed.connect(self.setAbbruch)
        widgetMessage.layout().addWidget(button)
        #button = QPushButton(widgetMessage)
        #button.setText("Weiter")
        #widgetMessage.layout().addWidget(button)
        iface.messageBar().pushWidget(widgetMessage, Qgis.Info)

    def contactClip(self):
        self.toolButton2.setDefaultAction(self.action8)
        self.mapToolSel = IdentifyGeometry(self.mapCanvas)
        self.iface.mapCanvas().setMapTool(self.mapToolSel)
        self.mapToolSel.geomIdentified.connect(self.featureSelect2)
        rubberlist = []
        featurelist = []
        self.abbruch = False
        self.selectedFeature = None
        layer = self.iface.mapCanvas().currentLayer()
        try:
            if layer.type() == QgsMapLayer.VectorLayer:
                if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                    self.createCancellationMessage('Schablone wählen.')
                    while self.selectedFeature == None:
                        if self.abbruch == True:
                            raise NameError
                        QApplication.processEvents()
                    while len(featurelist) < 1 :
                        # Feature eins
                        while self.selectedFeature is None:
                            if self.abbruch == True:
                                raise NameError
                            QApplication.processEvents()

                        if self.selectedLayer.name() == 'E_Polygon':
                            fsel = self.selectedFeature
                            r = QgsRubberBand(iface.mapCanvas(), True)
                            r.setToGeometry(fsel.geometry(), None)
                            r.setColor(QColor(0, 0, 255, 180))
                            r.setWidth(5)
                            r.show()
                            rubberlist.append(r)
                            featurelist.append(self.selectedFeature)
                        layer.removeSelection()
                        self.selectedFeature = None
                        # Feature zwei
                        iface.messageBar().popWidget()
                        self.createCancellationMessage('Schnittobjekt wählen.')
                        while self.selectedFeature is None:
                            if self.abbruch == True:

                                for maker in rubberlist:
                                    iface.mapCanvas().scene().removeItem(maker)

                                raise NameError
                            QApplication.processEvents()
                        if self.selectedLayer.name() == 'E_Polygon':
                            featurelist.append(self.selectedFeature)
                            selection = self.selectedFeature



                for g in featurelist:
                    if g.id() != featurelist [0].id():
                        if (g.geometry().intersects(fsel.geometry())):
                            # clipping non selected intersecting features
                            attributes = g.attributes()
                            diff = QgsFeature()
                            diff.setGeometry(g.geometry().difference(fsel.geometry()))
                            # copy attributes from original feature
                            diff.setAttributes(attributes)
                            # add modified feature to layer
                            ptList = []
                            geo = diff.geometry().asPolygon()[0]
                            for i in range(len(geo)):
                                item = QgsPoint(diff.geometry().vertexAt(i).x(),
                                                diff.geometry().vertexAt(i).y())
                                ptList.append(item)
                            r = QgsRubberBand(iface.mapCanvas(), True)
                            r.setToGeometry(QgsGeometry.fromPolyline(ptList), None)
                            r.setColor(QColor(255, 0, 0))
                            r.setWidth(5)
                            r.show()
                            rubberlist.append(r)
                            delSelectFeature()

                            box = QMessageBox()
                            box.setIcon(QMessageBox.Question)
                            box.setWindowTitle('Frage')
                            box.setText('Wollen Sie das Ergebnis übernehmen?')
                            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                            buttonY = box.button(QMessageBox.Yes)
                            buttonY.setText('Übernehmen')
                            buttonN = box.button(QMessageBox.No)
                            buttonN.setText('Abbruch')

                            size = box.size()
                            desktopsize = QtWidgets.QDesktopWidget().screenGeometry()
                            top = (desktopsize.height() / 2) - (size.height() - 200)
                            left = (desktopsize.width() / 2) - (size.width())
                            box.move(left, top)

                            box.exec_()

                            if box.clickedButton() == buttonY:
                                layer.startEditing()
                                layer.addFeature(diff)
                                layer.deleteFeature(g.id())
                                layer.commitChanges()
                                layer.endEditCommand()

                            elif box.clickedButton() == buttonN:
                                layer.deleteFeature(diff.id())
                                #layer.commitChanges()
                                #layer.endEditCommand()
                                pass
        except NameError:
            QgsMessageLog.logMessage('Abbruch', 'T2G Archäologie', Qgis.Info)
            pass
        for maker in rubberlist:
            iface.mapCanvas().scene().removeItem(maker)

        #layer.commitChanges()
        #layer.endEditCommand()
        layer.removeSelection()
        iface.actionSelect().trigger()
        iface.messageBar().clearWidgets()
        #self.selectedFeature == None
        self.mapToolSel.geomIdentified.disconnect()


    def featureSelect2(self,layer,feature):
        self.selectedLayer = layer
        self.selectedFeature = feature
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))
        #layer.select(int(feature.id()))
        QgsMessageLog.logMessage(str(layer.name())+str(feature.id()), 'aaa', Qgis.Info)

    def selectFeatureChanged(self,fselected, fdeselected):
        QgsMessageLog.logMessage('sel' + str(fselected), 'T2G Archäologie', Qgis.Info)

        for value in fselected:
            if len(fselected) == 1:
                layer = getlayerSelectedFeatures()
                QgsMessageLog.logMessage('eins selectiert' + str(fselected), 'T2G Archäologie', Qgis.Info)
                QgsMessageLog.logMessage('select ' + str(layer.name()) + ' ' + str(fselected), 'T2G Archäologie', Qgis.Info)
                self.selFeatureTemp = layer.selectedFeatures()[0]
            if value in self.selectFeatures:
                pass
            else:
                self.selectFeatures.append(value)
                pass
        QgsMessageLog.logMessage('desel' + str(fdeselected), 'T2G Archäologie', Qgis.Info)
        for value in fdeselected:
            if value in self.selectFeatures:
                self.selectFeatures.remove(value)
        QgsMessageLog.logMessage('liste' + str(self.selectFeatures), 'T2G Archäologie', Qgis.Info)
        pass


    def canvasReleaseEvent(self, event):

        if event.button() == Qt.LeftButton:
            #self.addVertex(event.pos())
            QgsMessageLog.logMessage('Links', 'T2G Archäologie', Qgis.Info)
            pass
        elif event.button() == Qt.RightButton:
            QgsMessageLog.logMessage('Rechts', 'T2G Archäologie', Qgis.Info)


    def keyReleaseEvent(self, event):
        if event.key() == Qt.Key_Escape:
            QgsMessageLog.logMessage('Escape', 'T2G Archäologie', Qgis.Info)
            #self.stopCapturing()
        if event.key() == Qt.Key_Backspace or event.key() == Qt.Key_Delete:
            QgsMessageLog.logMessage('Delete', 'T2G Archäologie', Qgis.Info)
            #self.removeLastVertex()
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            QgsMessageLog.logMessage('Enter', 'T2G Archäologie', Qgis.Info)
            #self.finishOperation()
        event.accept()
        self.redrawActions()

    def pluginSichtbarkeit(self):
        if self.dockwidget is None:
            return
        if self.actionPluginSichtbarkeit.isChecked():
            self.dockwidget.hide()
            self.actionPluginSichtbarkeit.setIcon(QIcon(os.path.join(self.iconpfad, 'Sichtbar_aus.gif')))
        else:
            self.dockwidget.show()
            self.actionPluginSichtbarkeit.setIcon(QIcon(os.path.join(self.iconpfad, 'Sichtbar_an.gif')))


class PrintClickedPoint(QgsMapToolEmitPoint):
    geomPoint = pyqtSignal()
    def __init__(self,canvas,dlg):
        self.canvas = canvas
        QgsMapToolEmitPoint.__init__(self, self.canvas)
        self.dlg=dlg

    def canvasMoveEvent( self, e ):
        try:
            point = self.toMapCoordinates(self.canvas.mouseLastXY())
            point = e.originalMapPoint()
            point = e.snapPoint()
            self.dlg.activateWindow()
            #self.dlg.txtPoint_2.setText(str(point.x())+','+str(point.y()))
        except:
            pass
    def canvasPressEvent( self, e ):
        try:
            point = e.snapPoint()
            self.dlg.activateWindow()
            self.dlg.txtPointTemp.setText(str(point.x())+','+str(point.y()))
        except:
            pass

class MyWnd(QMainWindow):

    def __init__(self, iface):
        QMainWindow.__init__(self)

        self.canvas = QgsMapCanvas(iface.mapCanvas())
        self.canvas.setCanvasColor(QtCore.Qt.white)
        #self.canvas.setExtent(iface.activeLayer().extent())
        self.canvas.setParallelRenderingEnabled(True)
        self.canvas.setLayers(iface.mapCanvas().layers())
        self.setCentralWidget(self.canvas)
        #self.canvas.zoomToFullExtent()
        ex = iface.mapCanvas().extent()
        self.canvas.setExtent(QgsRectangle(ex.xMaximum(), ex.yMaximum(), ex.xMinimum(),ex.yMinimum()))

        actionZoomIn = QAction("Zoom in", self)
        actionZoomOut = QAction("Zoom out", self)
        actionPan = QAction("Pan", self)
        actionZoomIn.setCheckable(True)
        actionZoomOut.setCheckable(True)
        actionPan.setCheckable(True)

        #self.connect(actionZoomIn, QtCore.SIGNAL("triggered()"), self.zoomIn)
        #self.connect(actionZoomOut, QtCore.SIGNAL("triggered()"), self.zoomOut)
        #self.connect(actionPan, QtCore.SIGNAL("triggered()"), self.pan)

        self.toolbar = self.addToolBar("Canvas actions")
        self.toolbar.addAction(actionZoomIn)
        self.toolbar.addAction(actionZoomOut)
        self.toolbar.addAction(actionPan)

        # create the map tools
        self.toolPan = QgsMapToolPan(self.canvas)
        self.toolPan.setAction(actionPan)
        self.toolZoomIn = QgsMapToolZoom(self.canvas, False) # false = in
        self.toolZoomIn.setAction(actionZoomIn)
        self.toolZoomOut = QgsMapToolZoom(self.canvas, True) # true = out
        self.toolZoomOut.setAction(actionZoomOut)
        self.pan()

    def zoomIn(self):
        self.canvas.setMapTool(self.toolZoomIn)

    def zoomOut(self):
        self.canvas.setMapTool(self.toolZoomOut)

    def pan(self):
        self.canvas.setMapTool(self.toolPan)
