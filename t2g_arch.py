# -*- coding: utf-8 -*-
"""
/***************************************************************************
 T2G_Arch
                                 A QGIS plugin
 Archäologie-PlugIn für Tachy2Gis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-17
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Daniel Timmel
        email                :
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QSize, QTimer, pyqtSlot, pyqtSignal, QPoint, QVariant, QObject
from PyQt5.QtGui import *#QIcon, QPixmap
from PyQt5.QtWidgets import *#QAction, QMessageBox, QFileDialog, QTreeWidgetItem, QInputDialog
from qgis.core import QgsProject, QgsExpressionContextUtils, QgsMessageLog, Qgis, QgsVectorLayer, QgsFeature,QgsWkbTypes, QgsField
from qgis.utils import iface, plugins
from qgis.gui import QgisInterface
from PyQt5.QtWidgets import QApplication as qApp
from .t2g_arch_dockwidget import T2G_ArchDockWidget
import os, csv, math
from datetime import date, datetime
import operator, subprocess
import os.path
import uuid
from osgeo import gdal
from .functions import *
from .ExtDialoge.myDlgAutoAttribut import *
from .ExtDialoge.myDlgDrucklayout import *
from .ExtDialoge.myDlgGPStoShape import *
from .ExtDialoge.myDlgAttributverwaltung import *
from .ExtDialoge.myDwgFeatureQuestion import *
from .identifygeometry import IdentifyGeometry
from .ExtDialoge.myDwgFeatureQuestion import FeatureQuestionDockWidget
from .ExtDialoge.myDlgQuery import AllLayerQuestionDockWidget
from .ExtDialoge.myDlgGeometryCheck import GeometryCheckDockWidget
from .ExtDialoge.myDlgRasterLayerView import RasterLayerViewDockWidget
from .ExtDialoge.myDwgLookForMissingAttributes import LookForMissingAttributesDockWidget

from .transformation.transformation_gui import TransformationGui
from .geoEdit.geo_edit import GeoEdit
from .profile.profile import Profile


VERSION = 'LfA Sachsen ' + 'V 0.5.1' + ' für Qgis 3.10 -'

class T2G_Arch:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        print('constructor')
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        self.mapCanvas = iface.mapCanvas()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'T2G_Arch_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.myactions = []
        self.menu = self.tr(u'&T2G Archäologie')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'T2G_Arch')
        self.toolbar.setObjectName(u'T2G_Arch')

        #print "** INITIALIZING T2G_Arch"

        self.pluginIsActive = False
        self.dockwidget = None

        self.dwFeatureQuestion = None
        self.dwAllLayerQuestion = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('T2G_Arch', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        print('startRun')
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        print('initGui')
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        iconpfad = os.path.join(os.path.dirname(__file__), 'Icons')
        icon_path = os.path.join(self.plugin_dir,'icon.png')
        self.add_action(
            icon_path,
            text=self.tr(u'T2G-Archäologie'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #my Toolbuttons
        iconVisibleApp = QIcon(os.path.join(iconpfad, 'Sichtbar_an.gif'))
        self.actionPluginSichtbarkeit = QAction(iconVisibleApp, u'Plugin Sichtbarkeit', self.iface.mainWindow())
        self.actionPluginSichtbarkeit.setCheckable(True)
        self.actionPluginSichtbarkeit.triggered.connect(self.pluginSichtbarkeit)
        self.toolbar.addAction(self.actionPluginSichtbarkeit)
        self.myactions.append(self.actionPluginSichtbarkeit)

        icon = QIcon(os.path.join(iconpfad, 'ordner-open.png'))
        self.actionProjectPfadExplorer = QAction(icon, u'Projektexplorer öffnen', self.iface.mainWindow())
        #self.actionProjectPfadExplorer.setCheckable(True)
        self.actionProjectPfadExplorer.triggered.connect(self.projectPfadExplorer)
        self.toolbar.addAction(self.actionProjectPfadExplorer)
        self.myactions.append(self.actionProjectPfadExplorer)

        icon2 = QIcon(os.path.join(iconpfad, 'FeatureQuest.gif'))
        self.actionFeatureQuestion = QAction(icon2, u'Geometrie abfragen', self.iface.mainWindow())
        #self.actionFeatureQuestion.setCheckable(True)
        self.actionFeatureQuestion.triggered.connect(self.featureQuestion)
        self.toolbar.addAction(self.actionFeatureQuestion)
        self.myactions.append(self.actionFeatureQuestion)
        self.toolbar.addSeparator()

        #Vermessung
        icon3 = QIcon(os.path.join(iconpfad, 'Einstellungen.gif'))
        icon4 = QIcon(os.path.join(iconpfad, 'media-floppy.png'))
        icon5 = QIcon(os.path.join(iconpfad, 'Befundnr.gif'))
        self.action1 = QAction(icon3, u'Autoattribute', self.iface.mainWindow())
        self.action2 = QAction(icon4, u'Tagesprojekt Sichern', self.iface.mainWindow())
        self.action3 = QAction(icon5, u'Befundnr setzen', self.iface.mainWindow())
        self.popupMenu = QMenu()
        self.myactions.append(self.popupMenu)
        self.popupMenu.addAction(self.action1)
        self.popupMenu.addAction(self.action2)
        self.popupMenu.addAction(self.action3)

        self.action1.triggered.connect(self.myDlgAutoAttributShow)
        self.action2.triggered.connect(self.dayProjectSave)
        self.action3.triggered.connect(self.klickPointLabel)

        self.toolButton = QToolButton()
        self.toolButton.setMenu(self.popupMenu)
        self.toolButton.setDefaultAction(self.action1)
        self.toolButton.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton)
        self.myactions.append(self.toolButton)

        # Tools Allgemein
        icon6 = QIcon(os.path.join(iconpfad, 'PunktImp.gif'))
        icon7 = QIcon(os.path.join(iconpfad, 'PunktExp.gif'))
        icon8 = QIcon(os.path.join(iconpfad, 'ProfPunktExp.gif'))
        self.action4 = QAction(icon6, u'Punkt Import', self.iface.mainWindow())
        self.action5 = QAction(icon7, u'Punkt Export', self.iface.mainWindow())
        self.action6 = QAction(icon8, u'Profilentzerrpunkte Export', self.iface.mainWindow())
        self.popupMenu2 = QMenu()
        self.myactions.append(self.popupMenu2)
        self.popupMenu2.addAction(self.action4)
        self.popupMenu2.addAction(self.action5)
        self.popupMenu2.addAction(self.action6)

        self.action4.triggered.connect(self.pointImp)
        self.action5.triggered.connect(self.pointExp)
        self.action6.triggered.connect(self.profEntzpointExp)

        self.toolButton1 = QToolButton()
        self.toolButton1.setMenu(self.popupMenu2)
        self.toolButton1.setDefaultAction(self.action4)
        self.toolButton1.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton1)
        self.myactions.append(self.toolButton1)

        # Tools Geometrie 1
        icon9 = QIcon(os.path.join(iconpfad, 'LineRe.gif'))
        icon10 = QIcon(os.path.join(iconpfad, 'butContactClip.gif'))
        self.action7 = QAction(icon9, u'Linie umdrehen', self.iface.mainWindow())
        self.action8 = QAction(icon10, u'an Geometrie anschließen', self.iface.mainWindow())

        self.popupMenu3 = QMenu()
        self.myactions.append(self.popupMenu3)
        self.popupMenu3.addAction(self.action7)
        self.popupMenu3.addAction(self.action8)

        self.action7.triggered.connect(self.lineFeatureReverse)
        self.action8.triggered.connect(self.contactClip)


        self.toolButton2 = QToolButton()
        self.toolButton2.setMenu(self.popupMenu3)
        self.toolButton2.setDefaultAction(self.action8)
        self.toolButton2.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton2)
        self.myactions.append(self.toolButton2)

        # Raster
        icon11 = QIcon(os.path.join(iconpfad, 'Thumbs.gif'))
        #icon4 = QIcon(os.path.join(iconpfad, 'media-floppy.png'))
        #icon5 = QIcon(os.path.join(iconpfad, 'Befundnr.gif'))
        self.action9 = QAction(icon11, u'Rasterlayer Übersicht', self.iface.mainWindow())
        #self.action2 = QAction(icon4, u'Tagesprojekt Sichern', self.iface.mainWindow())
        #self.action3 = QAction(icon5, u'Befundnr setzen', self.iface.mainWindow())
        self.popupMenu4 = QMenu()
        self.myactions.append(self.popupMenu4)
        self.popupMenu4.addAction(self.action9)
        #self.popupMenu.addAction(self.action2)
        #self.popupMenu.addAction(self.action3)

        self.action9.triggered.connect(self.myDlgRasterLayerShow)
        #self.action2.triggered.connect(self.dayProjectSave)
        #self.action3.triggered.connect(self.klickPointLabel)

        self.toolButton3 = QToolButton()
        self.toolButton3.setMenu(self.popupMenu4)
        self.toolButton3.setDefaultAction(self.action9)
        self.toolButton3.setPopupMode(QToolButton.MenuButtonPopup)
        self.toolbar.addWidget(self.toolButton3)
        self.myactions.append(self.toolButton3)

        for action in self.myactions:
            action.setEnabled(False)
        self.actions[0].setEnabled(True)

        self.watch = QTimer()
        self.QgisDateiPfad =''
        self.ProjPfad =''
        self.mapTool = IdentifyGeometry(self.mapCanvas)
        self.mapTool.geomIdentified.connect(self.editFeature)
        self.mapToolSel = IdentifyGeometry(self.mapCanvas)
        self.mapToolSel.geomIdentified.connect(self.featureSelect2)
        self.selectedLayer = None
        self.selectedFeature = None
        self.myDlgAutoAttribut = None
        self.selectFeatures = []
        self.selFeatureTemp = None

        self.iconpfad = os.path.join(os.path.dirname(__file__), 'Icons')
        self.xmlFile = xml(self.plugin_dir + '/settings.xml')

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        print('onClosePlugin')
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING T2G_Arch"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None
        self.pluginIsActive = False

        self.watch.stop()
        self.watch.timeout.disconnect(self.watchEvent)
        for action in self.actions:
            action.setEnabled(False)
        for action in self.myactions:
            action.setEnabled(False)
        self.actions[0].setEnabled(True)

    def unload(self):
        print('unload')
        """Removes the plugin menu item and icon from QGIS GUI."""

        delLayer("Profilentzerrpunkte AAR-Tool")
        #print "** UNLOAD T2G_Arch"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&T2G Archäologie'),
                action)
            self.iface.removeToolBarIcon(action)

        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    ## @brief Run method that loads and starts the plugin
    #
    # @param self
    def run(self):
        print('run')
        """Run method that loads and starts the plugin"""

        #if self.pluginIsActive:
        #    self.actions[0].setEnabled(True)
        #    for action in self.myactions:
        #        action.setEnabled(True)

        if not self.pluginIsActive:
            self.actions[0].setEnabled(True)
            self.pluginIsActive = True

            self.actions[0].setEnabled(False)
            for action in self.myactions:
                action.setEnabled(True)
            #print "** STARTING T2G_Arch"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = T2G_ArchDockWidget()
                #  connect to provide cleanup on closing of dockwidget
            self.valueTemp1 = None
            self.rubberBand = makerAndRubberbands()
            self.pointMaker = makerAndRubberbands()
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            self.dockwidget.butHilfe.setIcon(QIcon(os.path.join(self.iconpfad, 'Frage.gif')))
            self.dockwidget.butHilfe.setToolTip('Benutzerhandpuch')
            self.dockwidget.butHilfe.clicked.connect(self.help)
            self.dockwidget.butPunktExp.setIcon(QIcon(os.path.join(self.iconpfad, 'PunktExp.gif')))
            self.dockwidget.butPunktExp.setToolTip('Punkte Export')
            self.dockwidget.butPunktExp.clicked.connect(self.pointExp)
            self.dockwidget.butPunktImp.setIcon(QIcon(os.path.join(self.iconpfad, 'PunktImp.gif')))
            self.dockwidget.butPunktImp.setToolTip('Punkte Import')
            self.dockwidget.butProfEntzPunktExp.clicked.connect(self.profEntzpointExp)
            self.dockwidget.butProfEntzPunktExp.setIcon(QIcon(os.path.join(self.iconpfad, 'ProfPunktExp.gif')))
            self.dockwidget.butProfEntzPunktExp.setToolTip('Profilentzerrpunkte Export')
            self.dockwidget.butPunktImp.clicked.connect(self.pointImp)
            self.dockwidget.butAutoAtt.clicked.connect(self.myDlgAutoAttributShow)
            self.dockwidget.butAutoAtt.setIcon(QIcon(os.path.join(self.iconpfad, 'Einstellungen.gif')))
            self.dockwidget.butSchriftfeld.clicked.connect(self.myDlgDrucklayoutShow)
            self.dockwidget.butSchriftfeld.setIcon(QIcon(os.path.join(self.iconpfad, 'Schriftfeld.jpg')))
            self.dockwidget.txtAkt.textChanged.connect(self.setStatAttribute)
            self.dockwidget.cboArchGeo.currentIndexChanged.connect(self.setStatAttribute)

            self.dockwidget.butProfMe.clicked.connect(self.addProfil)
            #self.dockwidget.cboSuche.currentIndexChanged.connect(self.ozoom_1_ok)
            self.dockwidget.butObjFind.setIcon(QIcon(os.path.join(self.iconpfad, 'suchen.gif')))
            self.dockwidget.butObjFind.clicked.connect(self.ozoom_1_ok)
            self.dockwidget.cboSuche.setToolTip('Suchen')
            self.dockwidget.pushButton.clicked.connect(self.editLayerEncoding)
            self.dockwidget.butLayerFilter.clicked.connect(self.myDlgAllLayerQuestionShow)
            self.dockwidget.butLayerFilter.setToolTip('Filter auf alle Layer setzen')
            self.dockwidget.butDelAllFeatures.clicked.connect(self.delAllFeature)
            self.dockwidget.butDelAllFeatures.setToolTip('Löscht alle Geometrien auf den 3 Eingabelayern')
            self.dockwidget.butProfMe.clicked.connect(self.addProfil)
            self.dockwidget.butProfMe.setIcon(QIcon(os.path.join(self.iconpfad, 'icon.png')))
            self.dockwidget.butAttributverwaltung.clicked.connect(self.myDlgAttributverwaltungShow)

            self.layerLine = QgsProject.instance().mapLayersByName(T2G_ArchDockWidget.eLayerListe()[0])[0]
            self.layerPoly = QgsProject.instance().mapLayersByName(T2G_ArchDockWidget.eLayerListe()[1])[0]
            self.layerPoint = QgsProject.instance().mapLayersByName(T2G_ArchDockWidget.eLayerListe()[2])[0]
            self.layerMesspoint = QgsProject.instance().mapLayersByName('Messpunkte')[0]

            #self.layerLine.committedAttributeValuesChanges.connect(self.canvasRefresh)
            #self.layerPoly.committedAttributeValuesChanges.connect(self.canvasRefresh)
            #self.layerPoint.committedAttributeValuesChanges.connect(self.canvasRefresh)


            self.layerLine.featuresDeleted.connect(self.eventFeaturesDeleted)
            self.layerPoly.featuresDeleted.connect(self.eventFeaturesDeleted)
            self.layerPoint.featuresDeleted.connect(self.eventFeaturesDeleted)

            self.layerLine.editingStarted.connect(self.eventEditingStarted)
            self.layerPoly.editingStarted.connect(self.eventEditingStarted)
            self.layerPoint.editingStarted.connect(self.eventEditingStarted)

            self.layerLine.editingStopped.connect(self.eventEditingEnded)
            self.layerPoly.editingStopped.connect(self.eventEditingEnded)
            self.layerPoint.editingStopped.connect(self.eventEditingEnded)

            self.layerLine.subsetStringChanged.connect(self.FilterGesetzt)
            self.layerPoly.subsetStringChanged.connect(self.FilterGesetzt)
            self.layerPoint.subsetStringChanged.connect(self.FilterGesetzt)

            self.layerLine.attributeValueChanged.connect(self.eventAttributeValueChanged)
            self.layerPoly.attributeValueChanged.connect(self.eventAttributeValueChanged)
            self.layerPoint.attributeValueChanged.connect(self.eventAttributeValueChanged)

            self.dockwidget.chbautoSave.stateChanged.connect(self.enableAutoSave)
            self.dockwidget.txtautoSave.textChanged.connect(self.enableAutoSave)
            self.dockwidget.pushButton_3.clicked.connect(self.dayProjectSave)
            self.dockwidget.pushButton_3.setIcon(QIcon(os.path.join(self.iconpfad, 'media-floppy.png')))

            self.dockwidget.butFeatureFirst.clicked.connect(self.featureFirst)
            self.dockwidget.butFeatureFirst.setIcon(QIcon(os.path.join(self.iconpfad, '-gvor.gif')))
            self.dockwidget.butFeatureLast.clicked.connect(self.featureLast)
            self.dockwidget.butFeatureLast.setIcon(QIcon(os.path.join(self.iconpfad, '-ghinten.gif')))
            self.dockwidget.butAllLayfFilterEnt.clicked.connect(self.eventAllLayfFilterEnt)
            self.dockwidget.butAllLayfFilterEnt.setToolTip('Löscht alle Layerfilter')
            self.dockwidget.butAllLayfFilterEnt.setIcon(QIcon(os.path.join(self.iconpfad, 'FilterAllLayerEnt.gif')))
            self.dockwidget.butAllLayFilter.clicked.connect(self.eventAllLayFilter)
            self.dockwidget.butAllLayFilter.setToolTip('Setzt einen Filter auf alle Layer')
            self.dockwidget.butAllLayFilter.setIcon(QIcon(os.path.join(self.iconpfad, 'FilterAllLayer.gif')))
            self.dockwidget.butAllLayBefFilter.clicked.connect(self.eventAllLayBefFilter)
            self.dockwidget.butAllLayBefFilter.setToolTip('Setzt einen Befundfilter auf alle Layer')
            self.dockwidget.butAllLayBefFilter.setIcon(QIcon(os.path.join(self.iconpfad, 'FilterAllLayerBef.gif')))

            self.dockwidget.canvas_clicked = PrintClickedPoint(self.iface.mapCanvas(), self.dockwidget)
            self.dockwidget.butBefundLabel.clicked.connect(self.klickPointLabel)
            self.dockwidget.butBefundLabel.setIcon(QIcon(os.path.join(self.iconpfad, 'Befundnr.gif')))
            self.dockwidget.txtPointTemp.textChanged.connect(self.befundLabel)

            self.dockwidget.pushButton_4.setIcon(QIcon(os.path.join(self.iconpfad, 'V_Jpg-Tif.gif')))
            self.dockwidget.pushButton_4.clicked.connect(self.gtiff2jpg)
            self.dockwidget.pushButton_5.setIcon(QIcon(os.path.join(self.iconpfad, 'cut.gif')))
            self.dockwidget.pushButton_5.clicked.connect(self.rasterCut)
            self.dockwidget.pushButton_6.setIcon(QIcon(os.path.join(self.iconpfad, 'cutmask.gif')))
            self.dockwidget.pushButton_6.clicked.connect(self.setCutMask)
            self.dockwidget.pushButton_7.setIcon(QIcon(os.path.join(self.iconpfad, 'cutmaskdel.gif')))
            self.dockwidget.pushButton_7.clicked.connect(self.delCutMask)
            self.dockwidget.pushButton_11.setIcon(QIcon(os.path.join(self.iconpfad, 'Thumbs.gif')))
            self.dockwidget.pushButton_11.clicked.connect(self.myDlgRasterLayerShow)
            self.dockwidget.pushButton_11.setToolTip('Übersicht der Rasterlayer')

            self.iface.layerTreeView().currentLayerChanged.connect(self.currentLayerChanged)
            QgsProject.instance().customVariablesChanged.connect(self.customVariablesChanged)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)

            #Problem: durch self.dockwidget.setFixedWidth() verliert das dockWidget
            #die Möglichkeit geresized zu werden
            #die Layouts der einzelnen Abschnitte müssen responsive gemacht werden!
            #self.dockwidget.toolBox.currentChanged.connect(self.toolbox_currentChanged)
            self.dockwidget.show()
            self.layerPoly.selectionChanged.connect(self.selectFeatureChanged)

            self.dockwidget.pushButton_9.clicked.connect(self.myDlgFeatureCheckShow)
            self.watch.timeout.connect(self.watchEvent)

            ####################################################################
            ############################# Transformation #######################
            ####################################################################

            tGui = TransformationGui(self.dockwidget, self.iface)
            tGui.setup()
            ####################################################################

            ####################################################################
            ############################# Geometriebearbeitung #################
            ####################################################################

            self.geoEdit = GeoEdit(self, self.iface)
            self.geoEdit.setup()
            ####################################################################

            ####################################################################
            ############################# Profile #################
            ####################################################################

            self.profile = Profile(self, self.iface)
            self.profile.setup()
            ####################################################################

            self.dockwidget.butLookForMissingAttributes.clicked.connect(self.myDwgLookForMissingAttributesShow)

            self.setup()

    def setup(self):
        self.dockwidget.butFeatureFirst.hide()
        self.dockwidget.butFeatureLast.hide()
        self.dockwidget.butLayerFilter.hide()
        self.dockwidget.butDelAllFeatures.hide()
        self.dockwidget.butLookForMissingAttributes.hide()
        self.dockwidget.label_10.setText(VERSION)
        self.QgisDateiPfad = QgsProject.instance().readPath('./')
        self.ProjPfad = os.path.abspath(os.path.join(self.QgisDateiPfad, "./.."))

        self.currentLayerChanged()
        self.customVariablesChanged()  # self.getValue()

        self.getMaxValues()

        self.dockwidget.txtautoSave.setText('15')
        self.dockwidget.chbautoSave.setChecked(True)

        self.enableAutoSave()
        self.dockwidget.labAtt.hide()
        self.dockwidget.txtPointTemp.hide()

        iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Aufsatz Archäologie für T2G ist einsatzbereit.",
                                       level=Qgis.Info)
        QgsMessageLog.logMessage('Aufsatz Archäologie für T2G ist einsatzbereit.', 'T2G Archäologie', Qgis.Info)
        self.myDlgAutoAttribut = dlgAutoAttribut(self.iface, self.dockwidget)

        delSelectFeature()
        self.selectFeatures = []
        QgsMessageLog.logMessage('Überprüfe UUID', 'T2G Archäologie', Qgis.Info)
        iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Überprüfe UUID.", level=Qgis.Info)
        # >uuid ereugen wenn Feld uuid leer
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]

        for layer in list:
            layer.startEditing()
            if layer.dataProvider().fieldNameIndex("uuid") == -1:
                layer.dataProvider().addAttributes([QgsField("uuid", QVariant.String, len=50)])
                fIndex = layer.dataProvider().fieldNameIndex('uuid')
                layer.setDefaultValueDefinition(fIndex, QgsDefaultValue('uuid()'))
                layer.updateFields()
            it = layer.getFeatures(QgsFeatureRequest().setFilterExpression(u'"uuid" IS NULL'))
            #QgsMessageLog.logMessage(str(it.count()), 'T2G Archäologie', Qgis.Info)
            UUid = layer.dataProvider().fieldNameIndex('uuid')
            for feature in it:
                layer.changeAttributeValue(feature.id(), UUid, '{' + str(uuid.uuid4()) + '}')
            layer.commitChanges()
        # <uuid ereugen wenn Feld uuid leer

        self.FilterGesetzt()


    def toolbox_currentChanged(self,index):
        QgsMessageLog.logMessage(str(index), 'T2G Archäologie', Qgis.Info)
        if index == 1 or index == 4:
            self.dockwidget.setFixedWidth(390)
        else:
            self.dockwidget.setFixedWidth(200)


    def pluginSichtbarkeit(self):
        if self.dockwidget is None:
            return
        if self.actionPluginSichtbarkeit.isChecked():
            self.dockwidget.hide()
            self.actionPluginSichtbarkeit.setIcon(QIcon(os.path.join(self.iconpfad, 'Sichtbar_aus.gif')))
        else:
            self.dockwidget.show()
            self.actionPluginSichtbarkeit.setIcon(QIcon(os.path.join(self.iconpfad, 'Sichtbar_an.gif')))

    def testMultiPart(self):
        layer = self.iface.mapCanvas().currentLayer()
        n_split_feats = 0
        n_new_feats = 0

        for feature in layer.selectedFeatures():
            geom = feature.geometry()
            # if feature geometry is multipart starts split processing
            if geom != None:
                if geom.isMultipart():
                    QgsMessageLog.logMessage('ist multipart', 'T2G Archäologie', Qgis.Info)
                    n_split_feats += 1
                    parts = geom.asGeometryCollection()
                    # Convert part to multiType to prevent errors in Spatialite
                    for part in parts:
                        #part.convertToMultiType()
                        #geom = part.asMultiPolygon()

                        for vertex in part.vertices():
                            #koord = {'x': part.vertexAt(i).x(), 'y': part.vertexAt(i).y(),
                            #         'z': part.vertexAt(i).z()}
                            koord = {'x': vertex.x(), 'y': vertex.y(), 'z': vertex.z()}
                            #QgsMessageLog.logMessage('', 'T2G Archäologie', Qgis.Info)
                            QgsMessageLog.logMessage(str(koord), 'T2G Archäologie', Qgis.Info)
                            pass
                        QgsMessageLog.logMessage(str(len(geom.get())), 'T2G Archäologie', Qgis.Info)



                    # from 2nd to last part create a new features using their
                    # single geometry and the attributes of the original feature
                    for i in range(1, len(parts)):
                        #QgsMessageLog.logMessage(str(parts[i].geometry().get()),'T2G Archäologie', Qgis.Info)

                        n_new_feats += 1
                        #new_feat = QgsVectorLayerUtils.createFeature(layer,
                                                                     #parts[i],
                                                                     #attributes)
                        #layer.addFeature(new_feat)
                    # update feature geometry to hold first part of geometry
                    # (this way one of the output features keeps the original Id)
                    #feature.setGeometry(parts[0])
                    #layer.updateFeature(feature)

    def file2temp(self):
        fileFunc().directory_del('C:/temp/#T2G-Arch#')
        QApplication.processEvents()
        layer = self.iface.mapCanvas().currentLayer()
        input_raster = str(unicode(layer.source()))
        input_raster_wld = str(unicode(layer.source()))[:-4] + '.wld'
        input_raster_jgw = str(unicode(layer.source()))[:-4] + '.jgw'
        os.makedirs('C:/temp/#T2G-Arch#')
        #QgsMessageLog.logMessage(input_raster [-4:], 'T2G Archäologie', Qgis.Info)
        fileFunc().file_copy(input_raster, 'C:/temp/#T2G-Arch#/temp' + input_raster [-4:])
        fileFunc().file_copy(input_raster_wld, 'C:/temp/#T2G-Arch#/temp' + input_raster_wld [-4:])
        fileFunc().file_copy(input_raster_jgw, 'C:/temp/#T2G-Arch#/temp' + input_raster_jgw [-4:])
        pass

    def setCutMask(self):
        cutlayer = QgsProject.instance().mapLayersByName('Schnittmaske')[0]
        actlayer = None
        for layer in QgsProject.instance().mapLayers().values():
            if layer.type() == QgsMapLayer.VectorLayer:
                if layer.selectedFeatureCount() > 0:
                    actlayer = layer
                    break
        if actlayer == None:
            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                           u"Keine Objekte gewählt! Abbruch",
                                           level=Qgis.Critical)
            return
        iface.actionCopyFeatures().trigger()
        iface.setActiveLayer(cutlayer)
        cutlayer.startEditing()
        iface.actionPasteFeatures().trigger()
        cutlayer.commitChanges()
        delSelectFeature()
        self.iface.actionSelectRectangle().trigger()

    def delCutMask(self):
        cutlayer = QgsProject.instance().mapLayersByName('Schnittmaske')[0]
        cutlayer.startEditing()
        listOfIds = [feat.id() for feat in cutlayer.getFeatures()]
        cutlayer.deleteFeatures(listOfIds)
        cutlayer.commitChanges()
        iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                       u"Maskenlayer gelöscht",
                                       level=Qgis.Info)

    def rasterCut(self):
        layer = self.iface.mapCanvas().currentLayer()#Picturelayer to cut

        if layer.type() == QgsMapLayer.RasterLayer:
            #if layer.source()[-3:] == 'tif':
            #    iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Diese Funktion geht nicht mit GeoTiffs!",
            #                                   level=Qgis.Critical)
            #    return
            pass
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                           u"Layer ist kein Rasterlayer!",
                                           level=Qgis.Critical)
            return
        self.file2temp()
        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle('Frage')
        box.setText('Neue Schnittmaske erstellen oder vorh. Maske verwenden.')
        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText('Neu')
        buttonY.setToolTip('Erstellt eine Schnittmaske durch zeichnen eines Polygons.')
        buttonN = box.button(QMessageBox.No)
        buttonN.setText('vorh. Maske')
        buttonN.setToolTip('Nutzt die Objekte im Layer Schnittmaske')
        box.exec_()

        cutlayer = QgsProject.instance().mapLayersByName('Schnittmaske')[0]
        iface.setActiveLayer(cutlayer)


        if box.clickedButton() == buttonY: #neu
            cutlayer.startEditing()
            listOfIds = [feat.id() for feat in cutlayer.getFeatures()]
            cutlayer.deleteFeatures(listOfIds)
            self.iface.mapCanvas().refresh()
            iface.actionAddFeature().trigger()
            while cutlayer.featureCount() < 1:
                QApplication.processEvents()
            cutlayer.commitChanges()
            QgsMessageLog.logMessage('Neues Objekt', 'T2G Archäologie', Qgis.Info)
            pass
        elif box.clickedButton() == buttonN: #Geometrie
            if cutlayer.featureCount() == 0:
                iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                               u"Keine Objekte auf Maskenlayer vorhanden! Abbruch",
                                               level=Qgis.Critical)
                return
        else:
            return
        iface.setActiveLayer(layer)
        input = str(unicode(layer.source()))


        try:
            layername = layer.name()
            masklayerpfad = str(cutlayer.source())
            masklayername = 'Schnittmaske'
            inputsrs = layer.crs().authid()
            outputsrs = layer.crs().authid()
            temp_input_raster = None
            for file in os.listdir('C:/temp/#T2G-Arch#'):
                if file == 'temp.jpg':
                    temp_input_raster = 'C:/temp/#T2G-Arch#/temp.jpg'
                elif file == 'temp.tif':
                    temp_input_raster = 'C:/temp/#T2G-Arch#/temp.tif'
            temp_output_raster = 'C:/temp/#T2G-Arch#/temp_cut.tif'
            item = ("keine","100", "75", "50", "25")

            kompress = None
            kompressv, ok = QInputDialog.getItem(None, 'Kompression', 'JPEG-Qualität eingeben', item, 1, False)
            if ok != True:
                return
            else:
                if kompressv == 'keine':
                    kompress = ''
                else:
                    kompress = '-co COMPRESS=JPEG -co JPEG_QUALITY=' + kompressv

            string = r'gdalwarp -s_srs ' + inputsrs + ' -t_srs ' + outputsrs + \
                     ' -of GTiff -cutline "' + masklayerpfad + '" -cl ' + masklayername + \
                     ' -crop_to_cutline -dstalpha ' + kompress + ' "' + temp_input_raster + '" "' + temp_output_raster + '"'
            os.system(string)
            QgsMessageLog.logMessage(str(string), 'T2G Archäologie', Qgis.Info)
            dlg = QFileDialog()
            output_file = dlg.getSaveFileName(None, "Speicherpfad", os.path.abspath(input),
                                                      "GeoTif (*.tif);;Jpeg mit World (*.jpg);;Alle (*.*)",initialFilter='Jpeg mit World (*.jpg)')
            QgsMessageLog.logMessage(str(output_file[0]), 'T2G Archäologie', Qgis.Info)
            if output_file[0] == '':
                fileFunc().directory_del('C:/temp/#T2G-Arch#')
                return

            if output_file[1] == 'GeoTif (*.tif)':
                s = os.path.splitext(output_file[0])[0]
                fileFunc().file_copy('C:/temp/#T2G-Arch#/temp_cut.tif', s + '.tif')
                iface.addRasterLayer(s + '.tif', os.path.basename(output_file[0])[:-4])

            elif output_file[1] == 'Jpeg mit World (*.jpg)':
                s = os.path.splitext(output_file[0])[0]
                temp_input_raster = temp_output_raster
                temp_output_raster = temp_output_raster[:-4] + '_trans.jpg'
                layer.crs().authid()
                string = r'gdal_translate -of Jpeg -co worldfile=yes -mask 4 "' + temp_input_raster + '" "' + temp_output_raster + '"'
                #string = r'gdal_translate -of Jpeg -scale -co worldfile=yes "' + temp_input_raster + '" "' + temp_output_raster + '"'
                os.system(string)
                fileFunc().file_copy('C:/temp/#T2G-Arch#/temp_cut_trans.jpg', s + '.jpg')
                fileFunc().file_copy('C:/temp/#T2G-Arch#/temp_cut_trans.wld', s + '.wld')
                iface.addRasterLayer(s + '.jpg', os.path.basename(output_file[0])[:-4])
            fileFunc().directory_del('C:/temp/#T2G-Arch#')
        except Exception as e:
            QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)
            fileFunc().directory_del('C:/temp/#T2G-Arch#')
            pass

        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle('Frage')
        box.setText('Ausgangsdatei löschen?')
        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText('Datei und Layer')
        buttonY.setToolTip('Löscht Datei und Layer')
        buttonN = box.button(QMessageBox.No)
        buttonN.setText('Layer')
        buttonN.setToolTip('Löscht nur denn Layer')
        buttonA = box.button(QMessageBox.Abort)
        buttonA.setText('Behalten')
        buttonA.setToolTip('Löscht keins von beiden')
        buttonA.setFocus()
        box.exec_()

        if box.clickedButton() == buttonY:
            QgsProject.instance().removeMapLayer(layer.id())
            a = 0
            for layer in QgsProject.instance().mapLayers().values():
                QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
                if input in layer.source():
                    a = a + 1
            if a == 0:
                fileFunc().file_del(input)
            else:
                iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                               u"Datei ist mehrfach als Layer eingefügt und kann nicht gelöscht werden.",
                                               level=Qgis.Critical)
        elif box.clickedButton() == buttonN:
            QgsProject.instance().removeMapLayer(layer.id())
            pass
        elif box.clickedButton() == buttonA:
            pass


    def gtiff2jpg(self):
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.RasterLayer and layer.source()[-3:] == 'tif':
            self.file2temp()
            try:
                layername = layer.name()
                input = str(unicode(layer.source()))

                inputtemp = r'C:/temp/#T2G-Arch#/temp.tif'
                outputtemp = r'C:/temp/#T2G-Arch#/temp_transf.jpg'

                string = r"gdal_translate -of JPEG -scale -co worldfile=yes " + '"' + inputtemp + '" "' + outputtemp + '"'
                os.system(string)

                output_file = QFileDialog.getSaveFileName(None, 'Speicherpfad',
                                                          os.path.abspath(input),
                                                          'Jpeg mit World (*.jpg);;Alle (*.*)')
                if output_file[0] == '':
                    fileFunc().directory_del('C:/temp/#T2G-Arch#')
                    return
                QgsMessageLog.logMessage(output_file[0][:-4] + '.jpg', 'T2G Archäologie', Qgis.Info)

                fileFunc().file_copy('C:/temp/#T2G-Arch#/temp_transf.jpg', output_file[0][:-4] + '.jpg')
                fileFunc().file_copy('C:/temp/#T2G-Arch#/temp_transf.wld', output_file[0][:-4] + '.wld')
                iface.addRasterLayer(output_file[0][:-4] + '.jpg', os.path.basename(output_file[0])[:-4])
                fileFunc().directory_del('C:/temp/#T2G-Arch#')
            except:
                fileFunc().directory_del('C:/temp/#T2G-Arch#')

            box = QMessageBox()
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Frage')
            box.setText('Datei löschen?')
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No |QMessageBox.Abort)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('GeoTIF')
            buttonY.setToolTip('Löscht GeoTiff und Layer')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('Layer')
            buttonN.setToolTip('Löscht denn Layer')
            buttonA = box.button(QMessageBox.Abort)
            buttonA.setText('Behalten')
            buttonA.setToolTip('Löscht keins von beiden')
            buttonA.setFocus()
            box.exec_()

            if box.clickedButton() == buttonY:
                QgsProject.instance().removeMapLayer(layer.id())
                a=0
                for layer in QgsProject.instance().mapLayers().values():
                    QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
                    if input in layer.source():
                        a=a+1
                if a == 0:
                    fileFunc().file_del(input)
                else:
                    iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                               u"Datei ist mehrfach als Layer eingefügt und kann nicht gelöscht werden.",
                                               level=Qgis.Critical)
            elif box.clickedButton() == buttonN:
                QgsProject.instance().removeMapLayer(layer.id())
                pass
            elif box.clickedButton() == buttonA:
                pass
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ",
                                           u"Layer ist kein Rasterlayer oder eine GeoTif!",
                                           level=Qgis.Critical)


    def eventEditingStarted(self):
        #QgsMessageLog.logMessage('Änderung Start', 'T2G Archäologie', Qgis.Info)
        self.valueTemp1 = int(getCustomProjectVariable('nextBefNr'))
        #setCustomProjectVariable('maxWerteAktualisieren', 'False')
        QgsMessageLog.logMessage(str(self.valueTemp1), 'T2G Archäologie', Qgis.Info)
        pass

    def eventEditingEnded(self):
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        self.iface.mapCanvas().refreshAllLayers()
        self.getMaxValues()

    def eventeFatureAdded(self, fid):
        QgsMessageLog.logMessage(str(fid) + 'Geometrie+neu', 'T2G Archäologie', Qgis.Info)

    def eventFeaturesDeleted(self, fid):
        self.getMaxValues()
        pass

    def eventAttributeValueChanged(self,fid,idx,value):
        #if self.myDlgAutoAttribut.groupBox_2.isChecked() == True:
        #    self.autoNummer()

        lay =  self.iface.activeLayer()
        try:
            field = lay.fields()[idx]
            QgsMessageLog.logMessage(str(fid) + ' ' + str(field.name()) + ' ' + str(value), 'T2G Archäologie',
                                     Qgis.Info)
        except IndexError:
            return
            pass
        #QgsMessageLog.logMessage(str(fid)+' '+str(field.name())+' '+ str(value), 'T2G Archäologie', Qgis.Info)
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        # >Zahl aus String extrahieren
        index = 0
        a=0
        zahl = ''
        while index < len(str(value)):
            letter = str(value)[index]
            if isNumber(letter):
                a=1
                zahl = zahl + letter
            else:
                if a==1:
                    break
            index = index + 1
        value = zahl
        # <Zahl aus String extrahieren
        if isNumber(str(value)):
            if field.name() == "bef_nr":
                if  int(value) >= int(getCustomProjectVariable('nextBefNr')):
                    setCustomProjectVariable('nextBefNr', str(int(value) + 1))
                    self.dockwidget.txtNextBef.setText(str(int(value) + 1))
            elif field.name() == "fund_nr":
                if int(value) >= int(getCustomProjectVariable('nextFundNr')):
                    setCustomProjectVariable('nextFundNr', str(int(value) + 1))
                    self.dockwidget.txtNextFund.setText(str(int(value) + 1))
            elif field.name() == "prof_nr":
                if int(value) >= int(getCustomProjectVariable('nextProfNr')):
                    setCustomProjectVariable('nextProfNr', str(int(value) + 1))
                    self.dockwidget.txtNextProf.setText(str(int(value) + 1))
            elif field.name() == "prob_nr":
                if int(value) >= int(getCustomProjectVariable('nextProbNr')):
                    setCustomProjectVariable('nextProbNr', str(int(value) + 1))
                    self.dockwidget.txtNextProb.setText(str(int(value) + 1))
        else:
            pass
            #iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Nächste freihe Nummer konnte nicht ermittelt werden.",
            #                               level=Qgis.Critical)


    def autoNummer(self):
        QgsMessageLog.logMessage('Auto Num', 'T2G Archäologie', Qgis.Info)
        if self.myDlgAutoAttribut.chkBefZahl.isChecked() == True:
            try:
                wert = int(getCustomProjectVariable('bef_nr'))
                setCustomProjectVariable('bef_nr', str(wert + 1))
            except:
                pass
        if self.myDlgAutoAttribut.chkProfZahl.isChecked() == True:
            try:
                wert = int(getCustomProjectVariable('prof_nr'))
                setCustomProjectVariable('prof_nr', str(wert + 1))
            except:
                pass
        if self.myDlgAutoAttribut.chkFundZahl.isChecked() == True:
            try:
                wert = int(getCustomProjectVariable('fund_nr'))
                setCustomProjectVariable('fund_nr', str(wert + 1))
            except:
                pass
        if self.myDlgAutoAttribut.chkProbZahl.isChecked() == True:
            try:
                wert = int(getCustomProjectVariable('prob_nr'))
                setCustomProjectVariable('prob_nr', str(wert + 1))
            except:
                pass
        if self.myDlgAutoAttribut.chkptnrZahl.isChecked() == True:
            try:
                wert = int(getCustomProjectVariable('ptnr'))
                setCustomProjectVariable('ptnr', str(wert + 1))
            except:
                pass

    def currentLayerChanged(self):
        setCustomProjectVariable('obj_type', '')
        setCustomProjectVariable('obj_art', '')
        setCustomProjectVariable('schnitt_nr', '')
        setCustomProjectVariable('bef_nr', '')
        setCustomProjectVariable('planum', '')
        setCustomProjectVariable('fund_nr', '')
        setCustomProjectVariable('prob_nr', '')
        setCustomProjectVariable('prof_nr', '')
        setCustomProjectVariable('material', '')
        setCustomProjectVariable('ptnr', '')
        setCustomProjectVariable('autoAttribute', 'False')
        setCustomProjectVariable('autoZahl', 'False')
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        setCustomProjectVariable('SignalGeometrieNeu', 'False')

    def customVariablesChanged(self):

        #if getCustomProjectVariable('maxWerteAktualisieren') == 'False':
        #    return

        QgsMessageLog.logMessage(('Variable geändert'), 'T2G Archäologie', Qgis.Info)
        self.dockwidget.labAtt.setText('')
        self.dockwidget.txtAkt.setText(getCustomProjectVariable('aktcode'))
        self.dockwidget.cboArchGeo.setCurrentText(getCustomProjectVariable('geo-arch'))

        if getCustomProjectVariable('autoAttribute') == 'True':
            self.dockwidget.labAtt.show()
            self.dockwidget.labAtt.setText('Auto  Attribute! ')
            self.dockwidget.labAtt.setStyleSheet("QLabel { Background-color : rgb(255, 99, 79) ; }")
        else:
            self.dockwidget.labAtt.hide()
            self.dockwidget.labAtt.setText('')
            self.dockwidget.labAtt.setStyleSheet("QLabel { Background-color : rgb(240, 240, 240) ; }")
        if getCustomProjectVariable('autoZahl') == 'True':
            self.dockwidget.labZahl.show()
            self.dockwidget.labZahl.setText('Auto Nummer! ')
            self.dockwidget.labZahl.setStyleSheet("QLabel { Background-color : rgb(255, 99, 79) ; }")
        else:
            self.dockwidget.labZahl.hide()
            self.dockwidget.labZahl.setText('')
            self.dockwidget.labZahl.setStyleSheet("QLabel { Background-color : rgb(240, 240, 240) ; }")


    def setStatAttribute (self):
        setCustomProjectVariable('aktcode', str(self.dockwidget.txtAkt.text()))
        setCustomProjectVariable('geo-arch', str(self.dockwidget.cboArchGeo.currentText()))

    def pointExp(self):
        self.toolButton1.setDefaultAction(self.action5)
        layer = iface.activeLayer()

        if layer.selectedFeatureCount() == 0 or layer.geometryType() != QgsWkbTypes.PointGeometry:
            QMessageBox.critical(None, "Meldung", u"Es sind keine Punkte selektiert oder es ist kein Punktlayer ausgewählt!", QMessageBox.Abort)
        else:
            output_file = QFileDialog.getSaveFileName(None, 'Speicherpfad',
                                                      QgsProject.instance().readPath('./../Jobs'),
                                                      'Excel (*.csv);;Alle Dateien (*.*)')
            if output_file[0] != '':
                output_file = open(output_file[0], 'w')

                feats = []

                for feat in layer.selectedFeatures():
                    pt = (feat.geometry().asWkt()).split(" ", 1)[1]
                    coord = pt.split(" ")
                    x = round(float((coord[0]).replace("(", "")), 3)
                    y = round(float((coord[1])), 3)
                    z = round(float((coord[2]).replace(")", "")), 3)
                    msgout = '%s, %s, %s, %s\n' % (feat["ptnr"], x, y, z)
                    feats.append(msgout)

                box = QMessageBox()
                box.setIcon(QMessageBox.Question)
                box.setWindowTitle('Frage')
                box.setText('Wie soll sortiert werden?')
                box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                buttonY = box.button(QMessageBox.Yes)
                buttonY.setText('Punkt Nr')
                buttonN = box.button(QMessageBox.No)
                buttonN.setText('Datum')
                box.exec_()

                if box.clickedButton() == buttonY:
                    s_feats = sorted(feats, key=operator.itemgetter(0))
                elif box.clickedButton() == buttonN:
                    s_feats = sorted(feats, key=operator.itemgetter(1))

                #write to csv
                for item in s_feats:
                    output_file.write(item.replace(' ', ''))
                output_file.close()
                QMessageBox.information(None, "Meldung", u"Fertig!")

    def pointImp(self):
        self.toolButton1.setDefaultAction(self.action4)
        result = QMessageBox.information(None, 'WICHTIG',
                                         'Dateiformat' + '\n' + 'ptnr , x , y , z' + '\n' + 'Möchten Sie fortfahren?            ',
                                         QMessageBox.Ok | QMessageBox.Cancel)
        layer = QgsProject.instance().mapLayersByName('E_Point')[0]
        if result == QMessageBox.Ok:
            input_file = QFileDialog.getOpenFileName(None, 'Quellpfad',
                                                     QgsProject.instance().readPath('./../Jobs'),
                                                     'Text (*.txt);;Excel (*.csv);;Alle Dateien (*.*)')

            dateiErw = os.path.splitext(input_file [0])[-1].lower()
            if input_file[0] != '':
                progress = progressBar('Fortschritt')
                QCoreApplication.processEvents()
                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'maxWerteAktualisieren', 'False')
                lineid = 0
                if dateiErw == '.csv':
                    file = open(input_file[0])
                    linecount = fileLineCount(input_file[0])
                    progress.setText(str(linecount)+' Punkte werden importiert')
                    progress.setMaximum(linecount)
                    for line in file:
                        progress.setValue(lineid)
                        a = str(line).split(',')[0].lstrip()
                        b = str(line).split(',')[1].lstrip()
                        c = str(line).split(',')[2].lstrip()
                        d = str(line).split(',')[3].lstrip()
                        pt = QgsPoint(float(b), float(c), float(d))
                        attL = {'ptnr': a}
                        addPoint3D(layer, pt, attL)
                        lineid = lineid + 1
                    file.close()
                elif dateiErw == '.txt':
                    file = open(input_file[0])
                    linecount = fileLineCount(input_file[0])
                    progress.setText(str(linecount) + ' Punkte werden importiert')
                    progress.setMaximum(linecount)
                    for  line in file:
                        progress.setValue(lineid)
                        a = str(line)[0:15].lstrip()
                        b = str(line)[16:32].lstrip()
                        c = str(line)[33:44].lstrip()
                        d = str(line)[45:53].lstrip()
                        QgsMessageLog.logMessage(d, 'T2G Archäologie', Qgis.Info)
                        pt = QgsPoint(float(b), float(c), float(d))
                        attL = {'ptnr': a}
                        addPoint3D(layer, pt, attL)
                        lineid = lineid + 1
                    file.close()
                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'maxWerteAktualisieren', 'True')

                iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Messpunkte eingetragen.",
                                   level=Qgis.Info)

    ### profEntzpointExp_ergaenzt.py
    ### Erweiterung der Funktion für maximale Kkomaptibilität der expotierten .csv mit ProfileAAR:
    ### 1. Bestimmung der Ausrichtung des Profils "view" (dazu muss zunächst die zu den Punkten passende Profillinie gesucht werden,
    ###    anschließend wird die Blickrichtung auf das Profil bestimmt: N = von Norden, E = von Osten, S = von Süden, W = von Westen)
    ###    und Hinzufügen des Werts in die csv
    ### 2. Hinzufügen der Profilnummer in die csv
    ### 3. Hinzufügen einer Spalte "use" (bestimmt in ProfileAAR, ob der Punkt für die Berechnung der Profillinie verwendet werden soll)
    ###    in die csv. Standardmäßig wird der Wert "1" vergeben
    ### Ergänzungen: C. Schubert (Landesamt für Archäologie Sachsen), 07.04.2020

    def profEntzpointExp(self):
        self.toolButton1.setDefaultAction(self.action6)
        profnr, ok = QInputDialog.getText(None, 'Profil', 'Profilnummer eingeben')
        if ok != True:
            return

        # Linien-Layer für Profillinie aussuchen
        profLayer = QgsProject.instance().mapLayersByName('E_Line')[0]
        suchstr = '"prof_nr"=' + '\'' + profnr + '\''
        it = profLayer.getFeatures(QgsFeatureRequest(QgsExpression(suchstr)))
        ids = [i.id() for i in it]
        profLayer.selectByIds(ids)
        if profLayer.selectedFeatureCount() == 0:
            QMessageBox.information(None, "Meldung", u"Kein Profil gefunden!")
            return
        elif profLayer.selectedFeatureCount() > 1:
            QMessageBox.information(None, "Meldung",
                                    str(profLayer.selectedFeatureCount()) + u" Profile gefunden! Abbruch")
            return

        ### Anfang Blickrichtung bestimmen
        view = None
        koordlist = []
        for feat in profLayer.selectedFeatures():
            if feat.geometry().isMultipart():
                # Multipart
                parts = feat.geometry().asGeometryCollection()
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({'x': vertex.x(), 'y': vertex.y()})
                QgsMessageLog.logMessage(str(koordlist[0]['x']) , 'T2G Archäologie', Qgis.Info)
                pointAx = koordlist[0]['x']
                pointAy = koordlist[0]['y']
                pointBx = koordlist[-0]['x']
                pointBy = koordlist[-0]['y']
            else:
                # Singlepart
                pointA = feat.geometry().get()[0]
                pointB = feat.geometry().get()[-1]
                pointAx = pointA.x()
                pointAy = pointA.y()
                pointBx = pointB.x()
                pointBy = pointB.y()

            dx = pointBx - pointAx
            dy = pointBy - pointAy
            vp = [dx, dy]
            v0 = [-1, 1]
            # Lösung von hier: https://stackoverflow.com/questions/14066933/direct-way-of-computing-clockwise-angle-between-2-vectors/16544330#16544330, angepasst auf Berechnung ohne numpy
            dot = v0[0] * vp[0] + v0[1] * vp[1]  # dot product: x1*x2 + y1*y2
            det = v0[0] * vp[1] - vp[0] * v0[1]  # determinant: x1*y2 - y1*x2

            radians = math.atan2(det, dot)
            angle = math.degrees(radians)
            # negative Winkelwerte (3. und 4. Quadrant, Laufrichtung entgegen Uhrzeigersinn) in fortlaufenden Wert (181 bis 360) umrechnen
            if angle < 0:
                angle *= -1
                angle = 180 - angle + 180

            if angle <= 90:
                view = "N"
            elif angle <= 180:
                view = "W"
            elif angle <= 270:
                view = "S"
            elif angle > 270:
                view = "E"
    ### Ende Blickrichtung bestimmen


        feats = []
        ok = True
        profPointLayer = QgsProject.instance().mapLayersByName('E_Point')[0]
        such2 = '"obj_art"=\'Fotoentzerrpunkt\' and '
        #such2 = '"obj_type"=\'V_Referenzierungspunkt\' and '
        it = profPointLayer.getFeatures(QgsFeatureRequest(QgsExpression(str(such2 + suchstr))))
        QgsMessageLog.logMessage(str(such2 + suchstr), 'T2G Archäologie', Qgis.Info)
        ids = [i.id() for i in it]
        profPointLayer.selectByIds(ids)
        if profPointLayer.selectedFeatureCount() == 0:
            QMessageBox.information(None, "Meldung", u"Keine Profilentzerrpunkte gefunden!")
            return
        # QgsMessageLog.logMessage('aaa ' + len(geom.featureCount()), 'T2G Archäologie', Qgis.Info)

        for feat in profPointLayer.selectedFeatures():
            x = feat.geometry().get().x()  # round(float((coord[0]).replace("(", "")), 3)
            y = feat.geometry().get().y()  # round(float((coord[1])), 3)
            z = feat.geometry().get().z()  # round(float((coord[2]).replace(")", "")), 3)
            value = '---'
            try:
                value = feat["aktcode"] + '_' + feat["ptnr"]  # Fehler
            except Exception as e:
                QgsMessageLog.logMessage(str(e), 'T2G Archäologie', Qgis.Info)
                pass

            msgout = '%s, %s, %s, %s, %s, %s, %s\n' % (value, x, y, z, profnr, view, 1)
            if feat["obj_type"] != 'Fotoentzerrpunkt' or feat["prof_nr"] == '':
            #if feat["obj_art"] != 'Fotoentzerrungspunkt' or feat["prof_nr"] == '':
                ok = False
            feats.append(msgout)
        delLayer("Prof Entzerrpunkte AAR-Tool")
        box = QMessageBox()
        if ok == False:
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Frage')
            box.setText('Manche Punkte Sind keine Profilentzerrpunkte!')
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('OK')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('Abbruch')
            box.exec_()
            if box.clickedButton() == buttonY:
                ok = True
            elif box.clickedButton() == buttonN:
                ok = False

        if ok == True:
            box = QMessageBox()
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Frage')
            box.setText('Export als ...?')
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('Templayer')
            buttonY.setToolTip('Erzeugt einen temporären Layer.')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('CSV-Datei')
            buttonN.setToolTip('Erzeugt eine CSV Datei.')
            buttonA = box.button(QMessageBox.Abort)
            buttonA.setText('Beides')
            buttonA.setToolTip('Erzeugt einen temporären Layer und eine CSV-Datei.')
            buttonY.setFocus()
            box.exec_()

            if box.clickedButton() == buttonN or box.clickedButton() == buttonA :
                # csv-Datei
                output_file = QFileDialog.getSaveFileName(None, 'Speicherpfad',
                                                      QgsProject.instance().readPath('./../Jobs'),
                                                      'Excel (*.csv);;Alle Dateien (*.*)')
                if output_file[0] != '':
                    # write to csv
                    output_file = open(output_file[0], 'w')
                    for item in feats:
                        output_file.write(item.replace(' ', ''))
                    output_file.close()
            vl=None
            if box.clickedButton() == buttonY or box.clickedButton() == buttonA:
                # templayer erzeugen
                vl = QgsVectorLayer("Point", "Prof Entzerrpunkte AAR-Tool", "memory")
                # change memorylayer crs to layer crs
                vl.setCrs(profPointLayer.crs())
                pr = vl.dataProvider()
                pr.addAttributes([QgsField("punktnr", QVariant.String,'text'),
                                  QgsField("x", QVariant.Double,'double'),
                                  QgsField("y", QVariant.Double,'double'),
                                  QgsField("z", QVariant.Double,'double'),
                                  QgsField("profilnr", QVariant.Int,'integer'),
                                  QgsField("view", QVariant.String,'text'),
                                  QgsField("points used", QVariant.Int,'integer')])
                vl.updateFields()
                feat = QgsFeature()
                for item in feats:
                    it = item.split(',')
                    point = QgsPoint(float(it[1]), float(it[2]), float(it[3]))
                    feat.setGeometry(QgsGeometry(point))
                    feat.setAttributes([str(it[0]),point.x(),point.y(),point.z(),int(it[4]),str(it[5]),int(it[6])])
                    pr.addFeatures([feat])
                    #QgsMessageLog.logMessage(str(it[1]), 'T2G Archäologie', Qgis.Info)
                # add memorylayer to canvas
                QgsProject.instance().addMapLayer(vl, False)
                root = QgsProject.instance().layerTreeRoot()
                g = root.findGroup('Vermessung')
                g.insertChildNode(0, QgsLayerTreeLayer(vl))
            delSelectFeature()
            my_plugin = plugins.get('profileAAR')
            my_plugin.run()


    def getMaxValues(self):
        if getCustomProjectVariable('maxWerteAktualisieren') == 'True':
            #return
            layerLine = QgsProject.instance().mapLayersByName('E_Line')[0]
            layerPoly = QgsProject.instance().mapLayersByName('E_Polygon')[0]
            layerPoint = QgsProject.instance().mapLayersByName('E_Point')[0]
            layerlist = [layerLine, layerPoly, layerPoint]

            BefNrMax = 0
            FundNrMax = 0
            ProfNrMax = 0
            ProbNrMax = 0

            for layer in layerlist:

                max1 = maxValue(layer, 'bef_nr')

                #QgsMessageLog.logMessage(str(max1), 'T2G Archäologie', Qgis.Info)
                if BefNrMax < max1:
                    BefNrMax = max1

                max2 = maxValue(layer, 'fund_nr')
                if FundNrMax < max2:
                    FundNrMax = max2

                max3 = maxValue(layer, 'prob_nr')
                if ProbNrMax < max3:
                    ProbNrMax = max3

                max4 = maxValue(layer, 'prof_nr')
                if ProfNrMax < max4:
                    ProfNrMax = max4

                self.dockwidget.txtNextBef.setText(str(BefNrMax + 1))
                self.dockwidget.txtNextFund.setText(str(FundNrMax + 1))
                self.dockwidget.txtNextProf.setText(str(ProfNrMax + 1))
                self.dockwidget.txtNextProb.setText(str(ProbNrMax + 1))

                setCustomProjectVariable('nextBefNr', str(BefNrMax + 1))
                setCustomProjectVariable('nextProfNr', str(ProfNrMax + 1))
                setCustomProjectVariable('nextFundNr', str(FundNrMax + 1))
                setCustomProjectVariable('nextProbNr', str(ProbNrMax + 1))

            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Nächste zu vergebende Nummern wurden aktuallisiert.", level=Qgis.Info)
            setCustomProjectVariable('maxWerteAktualisieren', 'False')
            #self.autoNummer()

    def ObjNumberToList(self):
        self.dockwidget.treeWidget.clear()
        itemlist = ['Befunde', 'Funde', 'Profile', 'Proben']
        fieldnamelist = ['bef_nr', 'fund_nr', 'prof_nr', 'prob_nr']

        layerLine = QgsProject.instance().mapLayersByName('E_Line')[0]
        layerPoly = QgsProject.instance().mapLayersByName('E_Polygon')[0]
        layerPoint = QgsProject.instance().mapLayersByName('E_Point')[0]
        layerlist = [layerLine, layerPoly, layerPoint]

        a = 0

        for fieldname in fieldnamelist:
            a = a + 1
            list = []
            l = 0
            for layer in layerlist:
                l=l+1
                for field in layer.fields():
                    if field.name() == fieldname:
                        #QgsMessageLog.logMessage(str(fieldname), 'T2G Archäologie', Qgis.Info)
                        idField = layer.dataProvider().fieldNameIndex(fieldname)
                        for feat in layer.getFeatures():
                            attrs = feat.attributes()
                            if attrs[idField] != None:
                                try:
                                    val = str(attrs[idField] + '|' + layer.name())
                                    list.append(val)
                                    #QgsMessageLog.logMessage(str(val), 'T2G Archäologie', Qgis.Info)
                                except ValueError:
                                    pass
                try:
                    pass
                except ValueError:
                    list.append(0)
            list.sort()

            item = QTreeWidgetItem([itemlist[a-1]])
            for obj in list:
                obj = obj.split('|')
                item.addChild(QTreeWidgetItem([str(obj[0]),str(obj[1])]))

            self.dockwidget.treeWidget.addTopLevelItem(item)

        self.dockwidget.treeWidget.setSortingEnabled(True)
        self.dockwidget.treeWidget.sortByColumn(0,Qt.AscendingOrder)

    def ozoom_1_ok(self):
        #layer = QgsProject.instance().mapLayer(self.dockwidget.cbo_ozoom_1.currentLayer().id())
        layer = iface.activeLayer()
        layerLine = QgsProject.instance().mapLayersByName('E_Line')[0]
        layerPoly = QgsProject.instance().mapLayersByName('E_Polygon')[0]
        layerPoint = QgsProject.instance().mapLayersByName('E_Point')[0]
        layerlist = [layerLine, layerPoly, layerPoint]
        labellist = [self.dockwidget.labE_Line, self.dockwidget.labE_Poly, self.dockwidget.labE_Poi]
        layer.removeSelection()
        suchstr, ok = QInputDialog.getText(None,'Suchen','Nummer eingeben')
        if ok:
            if self.dockwidget.cboSuche.currentText() == 'Befund':
                fieldName = 'bef_nr'
            if  self.dockwidget.cboSuche.currentText() == 'Fund':
                fieldName = 'fund_nr'
            if  self.dockwidget.cboSuche.currentText() == 'Profil':
                fieldName = 'prof_nr'
            if  self.dockwidget.cboSuche.currentText() == 'Probe':
                fieldName = 'prob_nr'
            if suchstr[0] == '':
                return
            if isNumber(suchstr[0]):
                suchstr = fieldName + '=' + suchstr
            else:
                suchstr = fieldName + '=' + '\'' + suchstr + '\''
        else:
            return
        expr = QgsExpression(suchstr)#QgsExpression("befNr='120'")
        a = 0
        meldung = True
        for layer in layerlist:
            a = a + 1
            QgsMessageLog.logMessage(str(suchstr), 'T2G Archäologie', Qgis.Info)
            it = layer.getFeatures(QgsFeatureRequest(expr))
            ids = [i.id() for i in it]
            layer.selectByIds(ids)
            #self.dockwidget.lab_oselc_1.setText (str(layer.selectedFeatureCount()))

            if layer.selectedFeatureCount() > 0:
                self.iface.mapCanvas().zoomToSelected(layer)
                if not layer.geometryType() == QgsWkbTypes.PointGeometry:
                    self.iface.mapCanvas().zoomByFactor(5)
                self.iface.mapCanvas().refresh()
                labellist[a-1].setText(str(layer.selectedFeatureCount()))
                meldung = False
            else:
                labellist[a - 1].setText(str(layer.selectedFeatureCount()))
                if meldung != False:
                    meldung = True
        if meldung == True:
            QMessageBox.warning(None, "Meldung", 'Keine Objekte gefunden!')

    def lineFeatureReverse(self):
        self.toolButton2.setDefaultAction(self.action7)
        layer = self.iface.mapCanvas().currentLayer()
        if layer.geometryType() != QgsWkbTypes.LineGeometry:
            QMessageBox.information(None, 'WICHTIG', 'Falscher Geometrietyp!', QMessageBox.Cancel)
            return
        if layer.selectedFeatures() == []:
            QMessageBox.information(None, 'WICHTIG','Keine Geometrie gewählt!', QMessageBox.Cancel)
            return
        layer.startEditing()
        for feature in layer.selectedFeatures():
            geom = feature.geometry()
            if geom.isMultipart():
                mls = QgsMultiLineString()
                for line in geom.asGeometryCollection():
                    mls.addGeometry(line.constGet().reversed())
                newgeom = QgsGeometry(mls)
                layer.changeGeometry(feature.id(), newgeom)
            else:
                newgeom = QgsGeometry(geom.constGet().reversed())
                layer.changeGeometry(feature.id(), newgeom)

        layer.endEditCommand()
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
        iface.messageBar().pushMessage(u"Linienrichtung: ", u"gewechselt! Fertig.", level=Qgis.Info)

    def featureXMove(self):
        self.featureMove('x')
    def featureYMove(self):
        self.featureMove('y')
    def featureZMove(self):
        self.featureMove('z')

    def featureMove(self, koord):
        layer = iface.activeLayer()
        if len(layer.selectedFeatures()) == 0:
            QMessageBox.critical(None, "Meldung",
                                 u"Keine Objekte gewält!",
                                 QMessageBox.Ok)
            return
        dialog = QInputDialog()
        zvalue, ok = dialog.getText(None, 'Neuen ' + koord + '-Wert eingeben', '@ relativ, # absolut \n '
                                                                                     'keins von beiden -> absolut ',text='@', inputMethodHints=Qt.ImhNone)
        if ok:
            if layer.geometryType() != QgsWkbTypes.PointGeometry and (zvalue [0] == '#' or isNumber(zvalue) and koord != 'z'):
                QMessageBox.critical(None, "Meldung",
                                     u"Absolute Koordinaten(#) nur:\n "
                                     u"- bei Punktlayern im XYZ-Wert\n "
                                     u"- bei Linien- und Polygonlayern im Z-Wert möglich!",
                                     QMessageBox.Ok)
                return

            for feat in layer.selectedFeatures():
                QgsMessageLog.logMessage(str(feat.id()) + 'move', 'T2G Archäologie', Qgis.Info)
                inst = FeatureQuestionDockWidget(self.iface, layer, feat)

                k = 0
                for a in inst.koordList:
                    if zvalue[0] == '@':
                        inst.koordList[k][koord] = float(float(inst.koordList[k][koord]) + float(zvalue[1:]))
                    elif zvalue[0] == '#':
                        inst.koordList[k][koord] = float(zvalue[1:])
                    elif isNumber(zvalue):
                        inst.koordList[k][koord] = float(zvalue)
                    k = k + 1
                #inst.featureUpdate(layer,feat)
                inst.OK()
        else:
            delSelectFeature()

    def editLayerEncoding(self):

        for layer in QgsProject.instance().mapLayers().values():
            if layer.type() == QgsMapLayer.VectorLayer:
                layer.setProviderEncoding(u'UTF-8')
                layer.dataProvider().setEncoding(u'UTF-8')
                layer.dataProvider().capabilities()
                #QMessageBox.information(None, 'WICHTIG', str(layer.source()), QMessageBox.Cancel)

    def delAllFeature(self):
        result = QMessageBox.warning(None, "Achtung",
                             u"Wollen Sie wirklich alle Objekte\n "
                             u"auf den Eingabelayern löschen?",
                             QMessageBox.Ok,QMessageBox.Abort)
        if result == QMessageBox.Ok:
            list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
            for layer in list:

                #layer =  QgsProject.instance().mapLayersByName(layername)[0]
                layer.startEditing()
                QgsMessageLog.logMessage('Alle Objekte auf Layer ' + layer.name() + ' gelöscht.', 'T2G Archäologie', Qgis.Info)
                listOfIds = [feat.id() for feat in layer.getFeatures()]
                layer.deleteFeatures(listOfIds)
                layer.commitChanges()
        else:
            QgsMessageLog.logMessage('Abbruch', 'T2G Archäologie', Qgis.Info)
        pass


    def FilterGesetzt(self):
        #QgsMessageLog.logMessage('filter gesetzt', 'T2G Archäologie', Qgis.Info)
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in list:
            #QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
            if 'subset' in layer.source():
                self.dockwidget.txtNextBef.setText('xxxxx')
                self.dockwidget.txtNextFund.setText('xxxxx')
                self.dockwidget.txtNextProf.setText('xxxxx')
                self.dockwidget.txtNextProb.setText('xxxxx')
                #QgsMessageLog.logMessage('Filter gesetzt', 'T2G Archäologie', Qgis.Info)
        pass

    def eventAllLayfFilterEnt(self):
        for layer in QgsProject.instance().mapLayers().values():
            self.setLayerFilter('')
        setCustomProjectVariable('maxWerteAktualisieren', 'True')
        self.getMaxValues()

    def eventAllLayFilter(self):
        query, ok = QInputDialog().getText(None, 'Abfrage eingeben', '')
        if ok:
            self.setLayerFilter(query)
        else:
            self.eventAllLayfFilterEnt()

    def eventAllLayBefFilter(self):
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in list:
            layer.commitChanges()
        value, ok = QInputDialog().getText(None, 'Such Befund Nr eingeben', '')
        if ok:
            query = '"bef_nr" LIKE \'' + value + ',%\'' + \
                    ' or "bef_nr" LIKE ' + '\'%,' + value + ',%\'' + \
                    ' or "bef_nr" LIKE \'%,' + value + '\'' + \
                    ' or "bef_nr" LIKE ' + '\'' + value + '\''
            self.setLayerFilter(query)
        else:
            self.eventAllLayfFilterEnt()
            pass

        setSelectAllFeatures(self.layerPoly)
        delSelectFeature()

    def setLayerFilter(self,query):
        for layer in QgsProject.instance().mapLayers().values():
            if 'Line.shp' in layer.source() or 'Polygon.shp' in layer.source() or 'Point.shp' in layer.source():
                #QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)

                #QgsMessageLog.logMessage(query, 'T2G Archäologie', Qgis.Info)
                layer.setSubsetString(query)

    def addProfil(self):
        my_plugin = plugins.get('Tachy2GIS-master')#Tachy2GIS-master
        my_plugin.run()
        #my_plugin.exec_()
        #iface.showOptionsDialog()#.trigger()
        #for item in (plugins['Tachy2GIS-master'].iface.pluginMenu()).actions():
        #    QgsMessageLog.logMessage(str(item.text()), 'T2G Archäologie', Qgis.Info)
        #    if item.text() == '&Tachy2GIS':
        #        item.menu().actions()[0].activate(QAction.Trigger)
        #        break

    def myDlgAutoAttributShow(self):
            self.toolButton.setDefaultAction(self.action1)
            dialog = self.myDlgAutoAttribut
            dialog.show()
            dialog.setup()

    def myDlgDrucklayoutShow(self):
            dialog = dlgDrucklayout(self.iface)
            dialog.show()
    def myDlgGPStoShapeShow(self):
            dialog = dlgGPStoShape(self.iface)
            dialog.show()

    def myDlgAttributverwaltungShow(self):
        dialog = dlgAttributverwaltung(self.iface)
        dialog.show()

    def myDlgFeatureQuestionShow(self):
        #dialog = dlgFeatureQuestion(self.iface, self.selectedLayer, self.selectedFeature)
        iface.setActiveLayer(self.selectedLayer)
        self.dwFeatureQuestion = FeatureQuestionDockWidget(self.iface, self.selectedLayer, self.selectedFeature)
        self.dwFeatureQuestion.show()

    def myDlgAllLayerQuestionShow(self):
        #self.dwAllLayerQuestion = AllLayerQuestionDockWidget(self.iface)
        #self.dwAllLayerQuestion.show()
        pass

    def myDlgFeatureCheckShow(self):
        myDlgFeatureCheck = GeometryCheckDockWidget(self.iface,iface.mapCanvas())#mainWindow()
        myDlgFeatureCheck.setAutoFillBackground(True)
        myDlgFeatureCheck.show()

    def myDlgRasterLayerShow(self):
        self.toolButton3.setDefaultAction(self.action9)
        myDlgRasterLayerView = RasterLayerViewDockWidget(self.iface, iface.mapCanvas())  # mainWindow()
        myDlgRasterLayerView.setAutoFillBackground(True)
        myDlgRasterLayerView.show()

    def myDwgLookForMissingAttributesShow(self):
        self.dwLookForMissingAttributes = LookForMissingAttributesDockWidget(self.iface)#mainWindow()
        self.dwLookForMissingAttributes.show()
        self.dwLookForMissingAttributes.ui.cboFieldName.setCurrentText('bef_nr')

    def help(self):
        QMessageBox.information(None, 'Hilfe', os.path.join(self.ProjPfad, 'Hinweise.pdf'), QMessageBox.Cancel)
        subprocess.Popen(os.path.join(self.ProjPfad, 'Hinweise.pdf'),shell=True)

    def writeAutoAttribute(self):
        QgsMessageLog.logMessage("schreibe auto Attribute", 'T2G Archäologie', Qgis.Info)


    def enableAutoSave(self):
        if self.dockwidget.chbautoSave.isChecked():
            self.dockwidget.txtautoSave.setDisabled(False)
            self.watch.start(int(self.dockwidget.txtautoSave.text()) * 60000)
            QgsMessageLog.logMessage("Auto Backup: An, " + "Takt " + self.dockwidget.txtautoSave.text() + " min" , 'T2G Archäologie', Qgis.Info)
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: An, " + "Takt " + self.dockwidget.txtautoSave.text() + " min",
                                           level=Qgis.Info)
        else:
            self.dockwidget.txtautoSave.setDisabled(True)
            self.watch.stop()
            QgsMessageLog.logMessage("Auto Backup: Aus", 'T2G Archäologie', Qgis.Info)
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: Aus.",
                                           level=Qgis.Info)

    def watchEvent(self):
        projectSaveFunc().shapesSave()
        origFileName = QgsProject.instance().fileName()
        if origFileName != "":      #and QgsProject.instance().isDirty()
            bakFileName = origFileName + ".bak"
            fileFunc().file_del(bakFileName)
            QgsProject.instance().write()
            QgsProject.instance().write(bakFileName )
            QgsProject.instance().setFileName(origFileName)

        if projectSaveFunc().project_save(unicode(self.ProjPfad)) == 'False':
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: Fehler!",
                                           level=Qgis.Critical)
            QgsMessageLog.logMessage("Auto Backup: Fehler!", 'T2G Archäologie', Qgis.Critical)
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Auto Backup: Erstellt!",
                                           level=Qgis.Info)
            QgsMessageLog.logMessage("Auto Backup: Erstellt.", 'T2G Archäologie', Qgis.Info)

        ziel = os.path.join(self.ProjPfad, r'_Sicherungen_')
        ordner = []

        for folder in next(os.walk(ziel))[1]:
            ordner.append((str(folder)))

        for i in range(0, len(ordner) - 5):
            fileFunc().directory_del(os.path.join(ziel, ordner[i]))


    def projectPfadExplorer(self):
        self.iface.actionSelectRectangle().trigger()
        subprocess.call(r'explorer "' + self.ProjPfad + '"')

    def dayProjectSave(self):
        self.toolButton.setDefaultAction(self.action2)
        projectSaveFunc().shapesSave()
        QgsProject.instance().write()
        if projectSaveFunc().dayproject_save(unicode(self.ProjPfad)) == 'False':
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Speicherung Tagesdatei: Fehler!",
                                           level=Qgis.Critical)
            QgsMessageLog.logMessage("Speicherung Tagesdatei: Fehler!", 'T2G Archäologie', Qgis.Critical)
        else:
            iface.messageBar().pushMessage(u"T2G Archäologie: ", u"Speicherung Tagesdatei: Erfolgreich.",
                                           level=Qgis.Info)
            QgsMessageLog.logMessage("Speicherung Tagesdatei: Erfolgreich.", 'T2G Archäologie', Qgis.Info)

    def featureFirst(self):
        layer = iface.activeLayer()
        attL = {'anz_rei': 20}
        layer.startEditing()
        for feat in layer.selectedFeatures():
            featureAttributEdit(layer, feat, attL)
        layer.updateExtents()
        layer.commitChanges()


    def featureUp(self):
        pass

    def featureDown(self):
        pass

    def featureLast(self):
        layer = iface.activeLayer()
        attL = {'anz_rei': 0}
        layer.startEditing()
        for feat in layer.selectedFeatures():
            featureAttributEdit(layer, feat, attL)
        layer.updateExtents()
        layer.commitChanges()

    def featureQuestion(self):
        self.iface.mapCanvas().setMapTool(self.mapTool)

    def editFeature(self,layer,feature):
        delSelectFeature()
        self.selectedLayer = layer
        self.selectedFeature = feature
        koordlist=[]
        z =[]
        contextMenu = QtWidgets.QMenu()
        if layer.type() == QgsMapLayer.RasterLayer:
            pass

        # multipart
        elif self.selectedFeature.geometry().isMultipart():
            parts = self.selectedFeature.geometry().asGeometryCollection()
            if self.selectedLayer.geometryType() == QgsWkbTypes.PointGeometry:
                for part in parts:
                    for vertex in part.vertices():
                        m = self.pointMaker
                        m.setMaker(vertex.x(),vertex.y())
                pass

            else:
                koordlist = []
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({'x': vertex.x(), 'y': vertex.y(),'z': vertex.z()})
                        z.append(vertex.z())
                    r = self.rubberBand
                    r.setRubberBandPoly(koordlist)

            contextMenu.addAction('Z min:  ' + str(round(min(z), 2)))
            contextMenu.addAction('Z max:  ' + str(round(max(z), 2)))
        else:
        #singlepart
            if self.selectedLayer.geometryType() == QgsWkbTypes.PointGeometry:
                self.pointMaker.setMarker(self.selectedFeature.geometry().get().x(), self.selectedFeature.geometry().get().y())
                contextMenu.addAction('X: ' + str(self.selectedFeature.geometry().get().x()))
                contextMenu.addAction('Y: ' + str(self.selectedFeature.geometry().get().y()))
                contextMenu.addAction('Z: ' + str(self.selectedFeature.geometry().get().z()))
            elif layer.geometryType() == QgsWkbTypes.LineGeometry:
                n = len(self.selectedFeature.geometry().asPolyline()[0])
                z = []
                koordlist =[]
                for i in range(n):
                    z.append(float(self.selectedFeature.geometry().vertexAt(i).z()))
                    koordlist.append({'x': self.selectedFeature.geometry().vertexAt(i).x(),
                                      'y': self.selectedFeature.geometry().vertexAt(i).y(),
                                      'z': self.selectedFeature.geometry().vertexAt(i).z()})
                self.rubberBand.setRubberBandPoly(koordlist)
                contextMenu.addAction('Z min:  ' + str(round(min(z), 2)))
                contextMenu.addAction('Z max:  ' + str(round(max(z), 2)))

                zmit = ((max(z) - min(z)) / 2) + round(min(z), 2)
                contextMenu.addAction('Z mit:  ' + str(round(zmit, 2)))
                contextMenu.addAction('Länge:  ' + str(round(self.selectedFeature.geometry().length(), 2)) + ' m')
            elif self.selectedLayer.geometryType() == QgsWkbTypes.PolygonGeometry:
                z = []
                n = self.selectedFeature.geometry().asPolygon()[0]
                for i in range(len(n)):
                    koordlist.append({'x': self.selectedFeature.geometry().vertexAt(i).x(),
                                      'y': self.selectedFeature.geometry().vertexAt(i).y(),
                                      'z': self.selectedFeature.geometry().vertexAt(i).z()})
                    z.append(float(self.selectedFeature.geometry().vertexAt(i).z()))
                self.rubberBand.setRubberBandPoly(koordlist)

                contextMenu.addAction('Z min:  ' + str(round(min(z), 2)))
                contextMenu.addAction('Z max:  ' + str(round(max(z), 2)))

                zmit = ((max(z) - min(z)) / 2) + round(min(z), 2)
                contextMenu.addAction('Z mit:  ' + str(round(zmit, 2)))
                contextMenu.addAction('Fläche:  ' + str(round(self.selectedFeature.geometry().area(), 2)) + ' m2')

        #contextMenu.setStyleSheet("QMenu { Background-color : rgb(217, 241, 255) ; color : rgb(20, 50, 255)}")
        contextMenu.addAction("Layername: " + str(layer.name()))
        dlgFeatureQuestionTableShow = contextMenu.addAction(
            QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons","Liste.bmp")), "Attributtabelle")
        dlgFeatureQuestionTableShow.triggered.connect(self.showAttributeTable)
        dlgFeatureQuestionShow = contextMenu.addAction(
            QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons", "Formular.jpg")), "Geometriedaten")
        dlgFeatureQuestionShow.triggered.connect(self.myDlgFeatureQuestionShow)
        #contextMenu.addSeparator()
        FeatureSelect = contextMenu.addAction(
            QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons","FeatureSelect.gif")), "Geometrie auswählen")
        FeatureSelect.triggered.connect(self.featureSelect)
        #FeatureSelectExit = contextMenu.addAction(
        #    QtGui.QIcon(os.path.join(os.path.dirname(__file__), "Icons", "FeatureSelect.gif")), "Auswahl beenden.")
        #FeatureSelectExit.triggered.connect(self.featureSelectedExit)
        QgsMessageLog.logMessage(str(feature.id()), 'T2G Archäologie', Qgis.Info)
        contextMenu.addSeparator()


        attrs = self.selectedFeature.attributes()
        fields = self.selectedFeature.fields().toList()

        for i, attr in enumerate(attrs):
            name = fields[i].name()
            if str(attr) == 'NULL':
                attr = ''
            if name == 'aktcode':
                contextMenu.addAction('Grabung:  ' + str(attr))
            if name == 'obj_type':
                contextMenu.addAction('Objekttyp:  ' + str(attr))
            if name == 'obj_art':
                contextMenu.addAction('Objektart:  ' + str(attr))
            if name == 'schnitt_nr':
                contextMenu.addAction('Schnitt-Nr:  ' + str(attr))
            if name == 'bef_nr':
                contextMenu.addAction('Befund-Nr:  ' + str(attr))
            if name == 'fund_nr':
                contextMenu.addAction('Fund-Nr:  ' + str(attr))
            if name == 'prof_nr':
                contextMenu.addAction('Profil-Nr:  ' + str(attr))
            if name == 'planum':
                contextMenu.addAction('Planum:  ' + str(attr))
            if name == 'material':
                contextMenu.addAction('Material:  ' + str(attr))
            if name == 'geo-arch':
                contextMenu.addAction('geo/arch:  ' + str(attr))
            if name == 'ptnr':
                contextMenu.addAction('Punkt-Nr:  ' + str(attr))
        contextMenu.addAction('-----------------------')

        contextMenu.exec_(QtGui.QCursor.pos())
        self.rubberBand.rubberBandClean()
        self.pointMaker.makerClean()

    def featureSelect(self):
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))

    def showAttributeTable(self):
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))
        query = "id = " + str(int(self.selectedFeature.attributes()[0]))
        self.iface.showAttributeTable(self.selectedLayer,query)

    def klickPointLabel(self):
        self.toolButton.setDefaultAction(self.action3)
        self.iface.mapCanvas().setMapTool(self.dockwidget.canvas_clicked)

    def befundLabel(self):
        if self.dockwidget.txtPointTemp.text()=='':
            return
        x = self.dockwidget.txtPointTemp.text().split(',')[0]#5469621.4550791355
        y = self.dockwidget.txtPointTemp.text().split(',')[1]#5708874.320934738
        z = 0
        layer = QgsProject.instance().mapLayersByName('E_Point')[0]
        befnr, ok = QInputDialog.getText(None, '', 'Befund Nr. eingeben')
        if ok:
            pt = QgsPoint(float(x), float(y), float(z))
            attL = {'obj_type': 'Kartenbeschriftung', 'obj_art': 'Befund', 'bef_nr': befnr}
            addPoint3D(layer, pt, attL)
        iface.mapCanvas().refreshAllLayers()
        self.iface.actionSelectRectangle().trigger()
        self.dockwidget.txtPointTemp.setText('')
#polygon clipping preview
    def insideClip(self): # inside
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.VectorLayer:
            if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                selection = layer.selectedFeatures()
                if len(selection) != 0:
                    fsel = selection[0]
                    # set layer editable
                    layer.startEditing()
                    for g in layer.getFeatures():
                        if g.id() != fsel.id():
                            if (g.geometry().intersects(fsel.geometry())):
                                # clipping non selected intersecting features
                                attributes = g.attributes()
                                diff = QgsFeature()
                                diff.setGeometry(g.geometry().difference(fsel.geometry()))
                                # copy attributes from original feature
                                diff.setAttributes(attributes)
                                # add modified feature to layer
                                layer.addFeature(diff)
                                # remove old feature
                                layer.deleteFeature(fsel.id())

                        # refresh the view and clear selection
                    self.iface.mapCanvas().refresh()
                    self.iface.mapCanvas().currentLayer().selectAll()
                    self.iface.mapCanvas().currentLayer().invertSelection()

    def outsideClip(self): # outside
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.VectorLayer:
            if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                selection = layer.selectedFeatures()
                if len(selection) != 0:
                    fsel = selection[0]
                    # set layer editable
                    layer.startEditing()
                    for g in layer.getFeatures():
                        if g.id() != fsel.id():
                            if (g.geometry().intersects(fsel.geometry())):
                                # clipping non selected intersecting features
                                attributes = g.attributes()
                                diff = QgsFeature()
                                diff.setGeometry(fsel.geometry().difference(g.geometry()))
                                # copy attributes from original feature
                                diff.setAttributes(attributes)
                                # add modified feature to layer
                                layer.addFeature(diff)
                                # remove old feature
                                layer.deleteFeature(fsel.id())

                        # refresh the view and clear selection
                    self.iface.mapCanvas().refresh()
                    self.iface.mapCanvas().currentLayer().selectAll()
                    self.iface.mapCanvas().currentLayer().invertSelection()

    def contactClip(self):
        self.toolButton2.setDefaultAction(self.action8)
        rubberlist = []
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.VectorLayer:
            if layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                iface.messageBar().pushMessage(u"T2G Archäologie:  ", u"Vorlagenobjekt wählen.", level=Qgis.Info)
                self.iface.mapCanvas().setMapTool(self.mapToolSel)
                while len(layer.selectedFeatures()) == 0:
                    QApplication.processEvents()
                fsel =layer.selectedFeatures()[0]
                delSelectFeature()

                r = QgsRubberBand(iface.mapCanvas(), True)
                r.setToGeometry(fsel.geometry(), None)
                r.setColor(QColor(0, 0, 255, 180))
                r.setWidth(5)
                r.show()
                rubberlist.append(r)

                iface.messageBar().pushMessage(u"T2G Archäologie:  ", u"Zu schneidendes Objekt wählen.", level=Qgis.Info)

                while len(layer.selectedFeatures()) == 0 :
                    QApplication.processEvents()
                #QgsMessageLog.logMessage("weiter", 'T2G Archäologie', Qgis.Info)

                selection = layer.selectedFeatures()

                layer.startEditing()
                for g in selection:
                    if g.id() != fsel.id():
                        if (g.geometry().intersects(fsel.geometry())):
                            # clipping non selected intersecting features
                            attributes = g.attributes()
                            diff = QgsFeature()
                            diff.setGeometry(g.geometry().difference(fsel.geometry()))
                            # copy attributes from original feature
                            diff.setAttributes(attributes)
                            # add modified feature to layer
                            ptList = []
                            geo = diff.geometry().asPolygon()[0]
                            for i in range(len(geo)):
                                item = QgsPoint(diff.geometry().vertexAt(i).x(),
                                                diff.geometry().vertexAt(i).y())
                                ptList.append(item)
                            r = QgsRubberBand(iface.mapCanvas(), True)
                            r.setToGeometry(QgsGeometry.fromPolyline(ptList), None)
                            r.setColor(QColor(255, 0, 0))
                            r.setWidth(5)
                            r.show()
                            rubberlist.append(r)
                            delSelectFeature()

                            box = QMessageBox()
                            box.setIcon(QMessageBox.Question)
                            box.setWindowTitle('Frage')
                            box.setText('Wollen Sie das Ergebnis übernehmen?')
                            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                            buttonY = box.button(QMessageBox.Yes)
                            buttonY.setText('Übernehmen')
                            buttonN = box.button(QMessageBox.No)
                            buttonN.setText('Abbruch')

                            size = box.size()
                            desktopsize = QtWidgets.QDesktopWidget().screenGeometry()
                            top = (desktopsize.height() / 2) - (size.height()-200)
                            left = (desktopsize.width() / 2) - (size.width())
                            box.move(left, top)

                            box.exec_()

                            if box.clickedButton() == buttonY:
                                layer.addFeature(diff)
                                layer.deleteFeature(g.id())
                                #indx = diff.fields().indexFromName('id')
                                #layer.changeAttributeValue(diff.id(),indx,diff.id())
                            elif box.clickedButton() == buttonN:
                                layer.deleteFeature(diff.id())
                                pass

                for maker in rubberlist:
                    iface.mapCanvas().scene().removeItem(maker)

                layer.commitChanges()
                #layer.startEditing()
                layer.removeSelection()
                iface.actionSelect().trigger()

    def featureSelect2(self,layer,feature):
        layer.select(int(feature.id()))

    def selectFeatureChanged(self,fselected, fdeselected):
        QgsMessageLog.logMessage('sel' + str(fselected), 'T2G Archäologie', Qgis.Info)

        for value in fselected:
            if len(fselected) == 1:
                layer = getlayerSelectedFeatures()
                QgsMessageLog.logMessage('eins selectiert' + str(fselected), 'T2G Archäologie', Qgis.Info)
                QgsMessageLog.logMessage('select ' + str(layer.name()) + ' ' + str(fselected), 'T2G Archäologie', Qgis.Info)
                self.selFeatureTemp = layer.selectedFeatures()[0]
            if value in self.selectFeatures:
                pass
            else:
                self.selectFeatures.append(value)
                pass
        QgsMessageLog.logMessage('desel' + str(fdeselected), 'T2G Archäologie', Qgis.Info)
        for value in fdeselected:
            if value in self.selectFeatures:
                self.selectFeatures.remove(value)
        QgsMessageLog.logMessage('liste' + str(self.selectFeatures), 'T2G Archäologie', Qgis.Info)
        pass


    def canvasReleaseEvent(self, event):

        if event.button() == Qt.LeftButton:
            #self.addVertex(event.pos())
            QgsMessageLog.logMessage('Links', 'T2G Archäologie', Qgis.Info)
            pass
        elif event.button() == Qt.RightButton:
            QgsMessageLog.logMessage('Rechts', 'T2G Archäologie', Qgis.Info)


    def keyReleaseEvent(self, event):
        if event.key() == Qt.Key_Escape:
            QgsMessageLog.logMessage('Escape', 'T2G Archäologie', Qgis.Info)
            #self.stopCapturing()
        if event.key() == Qt.Key_Backspace or event.key() == Qt.Key_Delete:
            QgsMessageLog.logMessage('Delete', 'T2G Archäologie', Qgis.Info)
            #self.removeLastVertex()
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            QgsMessageLog.logMessage('Enter', 'T2G Archäologie', Qgis.Info)
            #self.finishOperation()
        event.accept()
        self.redrawActions()


class PrintClickedPoint(QgsMapToolEmitPoint):
    geomPoint = pyqtSignal()
    def __init__(self,canvas,dlg):
        self.canvas = canvas
        QgsMapToolEmitPoint.__init__(self, self.canvas)
        self.dlg=dlg

    def canvasMoveEvent( self, e ):
        try:
            point = self.toMapCoordinates(self.canvas.mouseLastXY())
            point = e.originalMapPoint()
            point = e.snapPoint()
            self.dlg.activateWindow()
            self.dlg.txtPoint_2.setText(str(point.x())+','+str(point.y()))
        except:
            pass
    def canvasPressEvent( self, e ):
        try:
            point = e.snapPoint()
            self.dlg.activateWindow()
            self.dlg.txtPointTemp.setText(str(point.x())+','+str(point.y()))
        except:
            pass
