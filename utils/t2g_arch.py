# -*- coding: utf-8 -*-
"""
/***************************************************************************
 T2G_Arch
                                 A QGIS bulugin
 Archäologie-PlugIn für Tachy2Gis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-03-17
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Daniel Timmel
        email                :
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import math
import operator
import os
import uuid

from qgis.PyQt.QtCore import QCoreApplication, QSettings, Qt, QTranslator, qVersion, QVariant
from qgis.PyQt.QtGui import QIcon, QCursor
from qgis.PyQt.QtWidgets import (
    QApplication,
    QFileDialog,
    QInputDialog,
    QMenu,
    QMessageBox,
)
from qgis.core import (
    Qgis,
    QgsCoordinateReferenceSystem,
    QgsDefaultValue,
    QgsExpression,
    QgsFeature,
    QgsFeatureRequest,
    QgsField,
    QgsGeometry,
    QgsLayerTreeLayer,
    QgsMapLayer,
    QgsMessageLog,
    QgsMultiLineString,
    QgsPoint,
    QgsProject,
    QgsVectorLayer,
    QgsWkbTypes,
    QgsApplication,
)
from qgis.gui import QgisInterface
from qgis.utils import plugins, active_plugins

from .functions import (
    addPoint3D,
    delLayer,
    delSelectFeature,
    fileFunc,
    findLayerInProject,
    fileLineCount,
    getCustomProjectVariable,
    getlayerSelectedFeatures,
    isNumber,
    makerAndRubberbands,
    maxValue,
    progressBar,
    ProjectSaveFunc,
    setCustomProjectVariable,
)
from .identifygeometry import IdentifyGeometry
from .t2g_arch_dockwidget import T2GArchDockWidget
from ..ExtDialoge.myDlgGeometryCheck import GeometryCheckDockWidget
from ..ExtDialoge.myDlgRasterLayerView import RasterLayerViewDockWidget
from ..ExtDialoge.myDlgSettings import DlgSettings, Configfile
from ..Icons import ICON_PATHS
from ..geoEdit.geo_edit import GeoEdit
from ..messen.messen import MeasurementTab
from ..profile.profile import Profile
from ..transformation.transformation_gui import TransformationGui

VERSION = "GDKE, RLP " + "V 1.0.0" + " für Qgis 3.20 -"

FN_PROFILNUMMER = "prof_nr"  # Feldname in der die Profilnummer steht
# Feldname in der die Entzerrpunkt-definition steht
FN_DEF_FOTOENTZERRPUNKT = "obj_typ"
AW_FOTOENTZERRPUNKT = "Fotoentzerrpunkt"  # Entzerrpunkt-definition


class T2gArch:
    def __del__(self):
        print("'PLUGIN DELETE SUCCESS' deleting T2gArch instance")
        if self.myDlgFeatureCheck:
            self.myDlgFeatureCheck.deleteLater()

    def __init__(self, iface: QgisInterface):
        if Qgis.QGIS_VERSION_INT < 32000:
            box = QMessageBox()
            box.setText(str(Qgis.QGIS_VERSION_INT))
            box.exec_()
            raise SystemExit

        self.myDlgFeatureCheck = None
        self.iface = iface
        self.plugin_name_tag = "T2G Archäologie"

        self.layerPoint = None
        self.layerLine = None
        self.layerPoly = None
        self.geoEdit = None

        self.mapCanvas = self.iface.mapCanvas()
        # initialize plugin directory
        self.plugin_dir = os.path.join(os.path.dirname(__file__), "..")

        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(self.plugin_dir, "i18n", "T2G_Arch_{}.qm".format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator(self.iface)
            self.translator.load(locale_path)

            if qVersion() > "4.3.3":
                QCoreApplication.installTranslator(self.translator)

        self.dock_widget_was_set_open = False

        self.pluginIsActive = False
        self.dockwidget = None

    def initGui(self):
        self.dockwidget = T2GArchDockWidget()
        self.setupModules()
        self.setupConnections()
        self.createMaptools()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        self.disconnectSignals()

        delLayer("Profilentzerrpunkte AAR-Tool")

        self.resetGui()
        self.pluginIsActive = False
        self.dockwidget.deleteLater()

    def furtherSetups(self):
        if not self.pluginIsActive:
            self.pluginIsActive = True

            # ToDo: refactoring: watch (autosave?) needed?
            # self.watch = QTimer()

            self.ProjPfad = ""

            self.selectedLayer = None
            self.selectedFeature = None

            self.dwFeatureQuestion = None
            self.dwAllLayerQuestion = None

            self.selectFeatures = []
            self.selFeatureTemp = None
            self.mapTool.geomIdentified.connect(self.editFeature)

            self.valueTemp1 = None
            self.rubberBand = makerAndRubberbands()
            self.pointMaker = makerAndRubberbands()

            self.layerLine = QgsProject.instance().mapLayersByName(T2GArchDockWidget.eLayerListe()[0])[0]
            self.layerLineId = self.layerLine.id()
            self.layerPoly = QgsProject.instance().mapLayersByName(T2GArchDockWidget.eLayerListe()[1])[0]
            self.layerPolyId = self.layerPoly.id()
            self.layerPoint = QgsProject.instance().mapLayersByName(T2GArchDockWidget.eLayerListe()[2])[0]
            self.layerPointId = self.layerPoint.id()
            self.layerMesspoint = QgsProject.instance().mapLayersByName("Messpunkte")[0]

            self.layerLine.featuresDeleted.connect(self.__eventFeaturesDeleted)
            self.layerPoly.featuresDeleted.connect(self.__eventFeaturesDeleted)
            self.layerPoint.featuresDeleted.connect(self.__eventFeaturesDeleted)

            self.layerLine.editingStarted.connect(self.eventEditingStarted)
            self.layerPoly.editingStarted.connect(self.eventEditingStarted)
            self.layerPoint.editingStarted.connect(self.eventEditingStarted)

            self.layerLine.subsetStringChanged.connect(self.filterGesetzt)
            self.layerPoly.subsetStringChanged.connect(self.filterGesetzt)
            self.layerPoint.subsetStringChanged.connect(self.filterGesetzt)

            self.lineLayerEdited = lambda fid, idx, value, lyr=self.layerPoly: self.eventAttributeValueChanged(
                fid, idx, value, lyr
            )
            self.pointLayerEdited = lambda fid, idx, value, lyr=self.layerPoint: self.eventAttributeValueChanged(
                fid, idx, value, lyr
            )
            self.polygonLayerEdited = lambda fid, idx, value, lyr=self.layerPoly: self.eventAttributeValueChanged(
                fid, idx, value, lyr
            )
            self.layerLine.attributeValueChanged.connect(self.lineLayerEdited)
            self.layerPoly.attributeValueChanged.connect(self.polygonLayerEdited)
            self.layerPoint.attributeValueChanged.connect(self.pointLayerEdited)

            self.layerLine.featureAdded.connect(self.eventFeatureAdded)
            self.layerPoly.featureAdded.connect(self.eventFeatureAdded)
            self.layerPoint.featureAdded.connect(self.eventFeatureAdded)

            # ToDo: refactoring - Tab "Tools Allgemein"
            self.dockwidget.butObjFind.setIcon(QIcon(ICON_PATHS["suchen"]))
            self.dockwidget.butObjFind.clicked.connect(self.ozoom_1_ok)
            self.dockwidget.cboSuche.setToolTip("Suchen")

            # ToDo: refactoring - Tab: "Tool Raster"
            self.dockwidget.pushButton_4.setIcon(QIcon(ICON_PATHS["V_Jpg-Tif"]))
            self.dockwidget.pushButton_4.clicked.connect(self.gtiff2jpg)
            self.dockwidget.pushButton_5.setIcon(QIcon(ICON_PATHS["cut"]))
            self.dockwidget.pushButton_5.clicked.connect(self.rasterCut)
            self.dockwidget.pushButton_6.setIcon(QIcon(ICON_PATHS["cutmask"]))
            self.dockwidget.pushButton_6.clicked.connect(self.setCutMask)
            self.dockwidget.pushButton_7.setIcon(QIcon(ICON_PATHS["cutmaskdel"]))
            self.dockwidget.pushButton_7.clicked.connect(self.delCutMask)
            self.dockwidget.pushButton_11.setIcon(QIcon(ICON_PATHS["Thumbs"]))
            self.dockwidget.pushButton_11.clicked.connect(self.myDlgRasterLayerShow)
            self.dockwidget.pushButton_11.setToolTip("Übersicht der Rasterlayer")

            # ToDo: Refactoring: "Einstellungen"-Button in main gui
            self.dockwidget.butSet.setIcon(QIcon(ICON_PATHS["Einstellungen"]))
            self.dockwidget.butSet.clicked.connect(self.myDlgSettingsShow)
            self.dockwidget.butSet.setToolTip("Setupdatei bearbeiten")

            # ToDo: refactoring: consistency with auto attributes in Tab "Vermessung", other project variables needed?
            # self.iface.layerTreeView().currentLayerChanged.connect(self.currentLayerChanged)

            self.layerPoly.selectionChanged.connect(self.selectFeatureChanged)

            # ToDo: refactoring- Tab "Tools Allgemein"
            self.dockwidget.btnCheckHeights.clicked.connect(self.myDlgFeatureCheckShow)

            self.dockwidget.btnBefundLabel.clicked.connect(self.setBefundLabel_n)

            # ToDo: Refactoring - watch (autosave?) needed?
            # self.watch.timeout.connect(self.watchEvent)
            self.iface.projectRead.connect(self.eventReadProject)
            self.__lastMaxNumber = []
            self.setup()

    def setup(self):
        self.iface.setActiveLayer(self.layerPoly)

        self.dockwidget.label_10.setText(VERSION)

        self.currentLayerChanged()
        self.getMaxValues()

        self.iface.messageBar().pushMessage(
            self.plugin_name_tag, "Aufsatz Archäologie für T2G ist einsatzbereit.", level=Qgis.Info
        )
        QgsMessageLog.logMessage("Aufsatz Archäologie für T2G ist einsatzbereit.", self.plugin_name_tag, Qgis.Info)

        delSelectFeature()
        self.selectFeatures = []
        QgsMessageLog.logMessage("Überprüfe UUID", self.plugin_name_tag, Qgis.Info)
        self.iface.messageBar().pushMessage(self.plugin_name_tag, "Überprüfe UUID.", level=Qgis.Info)
        # >uuid ereugen wenn Feld uuid leer
        layer_list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in layer_list:
            layer.startEditing()
            if layer.dataProvider().fieldNameIndex("uuid") == -1:
                layer.dataProvider().addAttributes([QgsField("uuid", QVariant.String, len=50)])
                fIndex = layer.dataProvider().fieldNameIndex("obj_uuid")
                layer.setDefaultValueDefinition(fIndex, QgsDefaultValue("uuid()"))
                layer.updateFields()
            it = layer.getFeatures(QgsFeatureRequest().setFilterExpression('"uuid" IS NULL'))
            # QgsMessageLog.logMessage(str(it.count()), 'T2G Archäologie', Qgis.Info)
            UUid = layer.dataProvider().fieldNameIndex("obj_uuid")
            for feature in it:
                layer.changeAttributeValue(feature.id(), UUid, "{" + str(uuid.uuid4()) + "}")
            layer.commitChanges()
        # <uuid ereugen wenn Feld uuid leer

        self.T2G = plugins.get([s for s in active_plugins if "Tachy2GIS" in s][0])
        # self.dockwidget.tabWidget_2.setCurrentIndex(0)
        self.iface.actionSelectRectangle().trigger()

        self.filterGesetzt()

        self.eventReadProject()
        # ToDo: refactoring - watch (autosave?) needed?
        self.watchEvent()

    def setupConnections(self):
        self.dockwidget.butHilfe.setToolTip("Benutzerhandbuch")
        self.dockwidget.butHilfe.clicked.connect(self.help)

        QgsProject.instance().layerRemoved.connect(self.checkForGdkeLayers)

    def disconnectSignals(self):
        QgsProject.instance().layerRemoved.disconnect(self.checkForGdkeLayers)
        if self.pluginIsActive:
            if self.layerPoint:
                self.layerPoint.featuresDeleted.disconnect(self.__eventFeaturesDeleted)
                self.layerPoint.editingStarted.disconnect(self.eventEditingStarted)
                self.layerPoint.subsetStringChanged.disconnect(self.filterGesetzt)
                self.layerPoint.attributeValueChanged.disconnect(self.pointLayerEdited)
                self.layerPoint.featureAdded.disconnect(self.eventFeatureAdded)
            if self.layerLine:
                self.layerLine.featuresDeleted.disconnect(self.__eventFeaturesDeleted)
                self.layerLine.editingStarted.disconnect(self.eventEditingStarted)
                self.layerLine.subsetStringChanged.disconnect(self.filterGesetzt)
                self.layerLine.attributeValueChanged.disconnect(self.lineLayerEdited)
                self.layerLine.featureAdded.disconnect(self.eventFeatureAdded)
            if self.layerPoly:
                self.layerPoly.featuresDeleted.disconnect(self.__eventFeaturesDeleted)
                self.layerPoly.editingStarted.disconnect(self.eventEditingStarted)
                self.layerPoly.subsetStringChanged.disconnect(self.filterGesetzt)
                self.layerPoly.attributeValueChanged.disconnect(self.polygonLayerEdited)
                self.layerPoly.featureAdded.disconnect(self.eventFeatureAdded)
            if self.geoEdit:
                self.geoEdit.disconnectSignals()

    def setupModules(self):
        # Messen
        self.measurementTab = MeasurementTab()
        self.dockwidget.tab_measurement.layout().addWidget(self.measurementTab)

    def stopVisdatModules(self):
        if self.geoEdit:
            self.geoEdit.disconnectSignals()

        # Transformation
        self.tGui = None

        # Geometriebearbeitung
        self.geoEdit = None

        # Profile
        self.profile = None

    def reloadVisdatModules(self):

        if self.geoEdit:
            self.geoEdit.disconnectSignals()

        # Transformation
        self.tGui = TransformationGui(self.dockwidget, self.iface)
        self.tGui.setup()

        # Geometriebearbeitung
        self.geoEdit = GeoEdit(self, self.iface)
        self.geoEdit.setup()

        # Profile
        self.profile = Profile(self, self.iface)
        self.profile.setup()

    def checkForGdkeLayers(self, e):
        if self.pluginIsActive:
            if e == self.layerPointId:
                self.layerPoint = None
            elif e == self.layerLineId:
                self.layerLine = None
            elif e == self.layerPolyId:
                self.layerPoly = None

    def createMaptools(self):
        self.mapTool = IdentifyGeometry(self.mapCanvas)
        self.mapTool.geomIdentified.connect(self.editFeature)

    def menuActionChanged(self, action, toolButton):
        toolButton.setDefaultAction(action)

    def stopPlugin(self):
        self.closeGui()

    def resetGui(self):
        self.openDockWidget(False)
        self.measurementTab.resetMeasurementTab()

    def closeGui(self):
        self.openDockWidget(False)
        self.measurementTab.closeMeasurementTab()

    # ------------ Toolbar ----------------
    def startAndStopPlugin(self, start: bool):
        if start:
            if not self._is_project_from_tachy_geopackage():
                QMessageBox.critical(None, "Critical", "Bitte Tachy-GeoPackage-Projekt laden und erneut versuchen.")
                return False

            self.reloadVisdatModules()
            self.furtherSetups()

            self.openDockWidget(True)
        else:
            self.stopVisdatModules()
            self.closeGui()
        return True

    def openDockWidget(self, set_open):
        print("openDockWidget", set_open)
        if set_open and not self.dock_widget_was_set_open:
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dock_widget_was_set_open = True
        elif not set_open and self.dock_widget_was_set_open:
            self.iface.removeDockWidget(self.dockwidget)
            self.dock_widget_was_set_open = False

    def importPoints(self):
        importPath = self.config.getValue("Punkte Import", "pfad Importordner", "./../Jobs")
        pointsLayer = findLayerInProject("E_Point")
        if not pointsLayer:
            return
        result = QMessageBox.information(
            None,
            "WICHTIG",
            "Dateiformat:\nptnr  x  y  z\n\nMöchten Sie fortfahren?",
            QMessageBox.Ok | QMessageBox.Cancel,
        )
        if result == QMessageBox.Ok:
            inputFile = QFileDialog.getOpenFileName(
                None,
                "Quellpfad",
                QgsProject.instance().readPath(importPath),
                "Vermessung (*.txt);;Text mit Komma (*.txt);;Text mit Tab (*.txt);;Excel (*.csv);;Alle Dateien (*.*)",
            )

            dateiFormat = os.path.splitext(inputFile[0])[-1].lower()
            if inputFile[0] != "":
                progress = progressBar("Fortschritt")
                QCoreApplication.processEvents()
                setCustomProjectVariable("maxWerteAktualisieren", False)

                if dateiFormat == ".csv":
                    QgsMessageLog.logMessage("Point import- read data from .csv", self.plugin_name_tag, Qgis.Info)
                    with open(inputFile[0]) as file:
                        lineCount = fileLineCount(inputFile[0])
                        progress.setText(f"{lineCount} Punkte werden importiert")
                        progress.setMaximum(lineCount)
                        pointNumber = 0
                        objCount = 0
                        for line in file:
                            progress.setValue(pointNumber)
                            lineList = line.split(",")
                            try:
                                a = lineList[0].strip()
                                b = lineList[1].strip()
                                c = lineList[2].strip()
                                d = lineList[3].strip()
                                pt = QgsPoint(float(b), float(c), float(d))
                                attL = {"pt_nr": a}
                                addPoint3D(pointsLayer, pt, attL)
                                objCount += 1
                            except:
                                QgsMessageLog.logMessage(
                                    f"Point import: Could not read point in line {pointNumber}",
                                    self.plugin_name_tag,
                                    Qgis.Info,
                                )
                            pointNumber += 1
                elif dateiFormat == ".txt":
                    QgsMessageLog.logMessage("Point import- read data from .txt", self.plugin_name_tag, Qgis.Info)
                    with open(inputFile[0]) as file:
                        lines = file.readlines()
                        lineCount = len(lines)
                        progress.setText(f"{lineCount} Punkte werden importiert")
                        progress.setMaximum(lineCount)
                        pointNumber = 0
                        objCount = 0
                        if "Komma" in inputFile[1]:
                            sep = ","
                        if "Tab" in inputFile[1]:
                            sep = "\t"
                        if "Vermessung" in inputFile[1]:
                            sep = "V"
                        for line in lines:
                            progress.setValue(pointNumber)
                            if sep != "V" and "." in line:
                                if "." in line:
                                    try:
                                        a = str(line).split(sep)[0].lstrip()
                                        b = str(line).split(sep)[1].lstrip()
                                        c = str(line).split(sep)[2].lstrip()
                                        d = str(line).split(sep)[3].lstrip()
                                        pt = QgsPoint(float(b), float(c), float(d))
                                        attL = {"pt_nr": a}
                                        addPoint3D(pointsLayer, pt, attL)
                                        objCount += 1
                                    except:
                                        QgsMessageLog.logMessage(
                                            f"Point import: Could not read point in line {pointNumber}",
                                            self.plugin_name_tag,
                                            Qgis.Info,
                                        )
                                else:
                                    self.iface.messageBar().pushMessage(
                                        self.plugin_name_tag,
                                        f"Fehler! Falscher Spaltentrenner oder vorhandene Kopfzeile in Zeile {pointNumber}.",
                                        level=Qgis.Critical,
                                    )
                            else:
                                try:
                                    a = str(line)[0:15].lstrip()
                                    b = str(line)[16:32].lstrip()
                                    c = str(line)[33:44].lstrip()
                                    d = str(line)[45:53].lstrip()
                                    pt = QgsPoint(float(b), float(c), float(d))
                                    attL = {"pt_nr": a}
                                    addPoint3D(pointsLayer, pt, attL)
                                    objCount += 1
                                except:
                                    QgsMessageLog.logMessage(
                                        f"Point import: Could not read point in line {pointNumber}",
                                        self.plugin_name_tag,
                                        Qgis.Info,
                                    )

                            pointNumber += 1
                setCustomProjectVariable("maxWerteAktualisieren", True)

                if objCount > 0:
                    self.iface.messageBar().pushMessage(
                        self.plugin_name_tag, f"{objCount} Punkte eingetragen.", level=Qgis.Info
                    )
                else:
                    self.iface.messageBar().pushMessage(
                        self.plugin_name_tag, "Keine Punkte eingetragen.", level=Qgis.Critical
                    )

    def exportPoints(self):
        exportPath = self.config.getValue("Punkte Export", "pfad Exportordner", "./../Jobs")
        # Should be: layer "Messpunkte" or layer 'E_Point'
        layer = self.iface.activeLayer()

        if layer.selectedFeatureCount() == 0 or layer.geometryType() != QgsWkbTypes.PointGeometry:
            QMessageBox.critical(
                None,
                "Meldung",
                "Es sind keine Punkte selektiert oder es ist kein Punktlayer ausgewählt!",
                QMessageBox.Abort,
            )
        else:
            outputFile = QFileDialog.getSaveFileName(
                None,
                "Speicherpfad",
                QgsProject.instance().readPath(exportPath),
                "Text (*.txt);;Excel (*.csv);;Alle Dateien (*.*)",
            )
            if outputFile[0] != "":
                with open(outputFile[0], "w") as outputFile:
                    feats = []
                    for feat in layer.selectedFeatures():
                        pt = (feat.geometry().asWkt()).split(" ", 1)[1]
                        coord = pt.split(" ")
                        x = round(float((coord[0]).replace("(", "")), 3)
                        y = round(float((coord[1])), 3)
                        z = round(float((coord[2]).replace(")", "")), 3)
                        msgout = f'{feat["pt_nr"]}, {x}, {y}, {z}\n'
                        feats.append(msgout)

                    box = QMessageBox()
                    box.setIcon(QMessageBox.Question)
                    box.setWindowTitle("Frage")
                    box.setText("Wie soll sortiert werden?")
                    box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                    buttonY = box.button(QMessageBox.Yes)
                    buttonY.setText("Punkt Nr")
                    buttonN = box.button(QMessageBox.No)
                    buttonN.setText("Datum")
                    box.exec_()

                    if box.clickedButton() == buttonY:
                        s_feats = sorted(feats, key=operator.itemgetter(0))
                    elif box.clickedButton() == buttonN:
                        s_feats = sorted(feats, key=operator.itemgetter(1))

                    # write to csv
                    for item in s_feats:
                        outputFile.write(item.replace(" ", ""))
                    outputFile.close()
                    QMessageBox.information(None, "Meldung", "Fertig!")

    def exportProfilePoints(self):
        # Exportpfad aus Configfile setzen
        exportpfad = self.config.getValue("Profilentzerrung", "pfad Exportordner")
        FN_PROFILNUMMER = self.config.getValue("Profilentzerrung", "feldNProfNr")
        FN_DEF_FOTOENTZERRPUNKT = self.config.getValue("Profilentzerrung", "feldNFEP")
        AW_FOTOENTZERRPUNKT = self.config.getValue("Profilentzerrung", "attFEP")
        profnr, ok = QInputDialog.getText(None, "Profil", "Profilnummer eingeben")
        if ok != True:
            return

        # Linien-Layer für Profillinie aussuchen
        profLayer = findLayerInProject("E_Line")
        profPointLayer = findLayerInProject("E_Point")
        if not profLayer or not profPointLayer:
            return

        suchstr = '"' + FN_PROFILNUMMER + '"=' + "'" + profnr + "'"
        it = profLayer.getFeatures(QgsFeatureRequest(QgsExpression(suchstr)))
        ids = [i.id() for i in it]
        profLayer.selectByIds(ids)

        if str(profLayer.selectedFeatureCount()) == "0":
            QMessageBox.information(None, "Meldung", "Kein Profil gefunden!")
            return
        elif profLayer.selectedFeatureCount() > 1:
            QMessageBox.information(None, "Meldung", f"{profLayer.selectedFeatureCount()} Profile gefunden! Abbruch")
            return

        # Anfang Blickrichtung bestimmen
        view = None
        koordlist = []
        for feat in profLayer.selectedFeatures():
            if feat.geometry().isMultipart():
                # Multipart
                parts = feat.geometry().asGeometryCollection()
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({"x": vertex.x(), "y": vertex.y()})
                QgsMessageLog.logMessage(str(koordlist[0]["x"]), self.plugin_name_tag, Qgis.Info)
                pointAx = koordlist[0]["x"]
                pointAy = koordlist[0]["y"]
                pointBx = koordlist[-0]["x"]
                pointBy = koordlist[-0]["y"]
            else:
                # Singlepart
                pointA = feat.geometry().get()[0]
                pointB = feat.geometry().get()[-1]
                pointAx = pointA.x()
                pointAy = pointA.y()
                pointBx = pointB.x()
                pointBy = pointB.y()

            dx = pointBx - pointAx
            dy = pointBy - pointAy
            vp = [dx, dy]
            v0 = [-1, 1]
            # Lösung von hier: https://stackoverflow.com/questions/14066933/direct-way-of-computing-clockwise-angle-between-2-vectors/16544330#16544330, angepasst auf Berechnung ohne numpy
            dot = v0[0] * vp[0] + v0[1] * vp[1]  # dot product: x1*x2 + y1*y2
            det = v0[0] * vp[1] - vp[0] * v0[1]  # determinant: x1*y2 - y1*x2

            radians = math.atan2(det, dot)
            angle = math.degrees(radians)
            # negative Winkelwerte (3. und 4. Quadrant, Laufrichtung entgegen Uhrzeigersinn) in fortlaufenden Wert (181 bis 360) umrechnen
            if angle < 0:
                angle *= -1
                angle = 180 - angle + 180

            if angle <= 90:
                view = "N"
            elif angle <= 180:
                view = "W"
            elif angle <= 270:
                view = "S"
            elif angle > 270:
                view = "E"
        # Ende Blickrichtung bestimmen

        feats = []
        ok = True
        # such2 = '"obj_art"=\'Fotoentzerrpunkt\' and '
        # such2 = '"obj_typ"=\'V_Referenzierungspunkt\' and '
        # such2 = '"obj_typ"='+ '\''+ AW_FOTOENTZERRPUNKT + '\' and '
        such2 = '"' + FN_DEF_FOTOENTZERRPUNKT + '"=' + "'" + AW_FOTOENTZERRPUNKT + "' and "
        it = profPointLayer.getFeatures(QgsFeatureRequest(QgsExpression(str(such2 + suchstr))))
        QgsMessageLog.logMessage(str(such2 + suchstr), self.plugin_name_tag, Qgis.Info)
        ids = [i.id() for i in it]
        profPointLayer.selectByIds(ids)
        if profPointLayer.selectedFeatureCount() == 0:
            QMessageBox.information(None, "Meldung", "Keine Profilentzerrpunkte gefunden!")
            return

        #######
        msgout = "%s, %s, %s, %s, %s, %s, %s\n" % ("punktnr", "x", "y", "z", "profnr", "view", "pointsused")
        feats.append(msgout)
        for feat in profPointLayer.selectedFeatures():
            koordlist = []
            if feat.geometry().isMultipart():
                # Multipart
                parts = feat.geometry().asGeometryCollection()
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({"x": vertex.x(), "y": vertex.y(), "z": vertex.z()})
                        QgsMessageLog.logMessage(str(vertex.z()), self.plugin_name_tag, Qgis.Info)
                x = koordlist[0]["x"]
                y = koordlist[0]["y"]
                z = koordlist[0]["z"]
            else:
                # Singlepart
                # round(float((coord[0]).replace("(", "")), 3)
                x = feat.geometry().get().x()
                y = feat.geometry().get().y()  # round(float((coord[1])), 3)
                # round(float((coord[2]).replace(")", "")), 3)
                z = feat.geometry().get().z()
                value = "---"
            try:
                value = str(feat["aktcode"]) + "_" + str(feat["pt_nr"])  # Fehler
            except Exception as e:
                QgsMessageLog.logMessage(str(e), self.plugin_name_tag, Qgis.Info)
                pass
            ###
            msgout = "%s, %s, %s, %s, %s, %s, %s\n" % (value, x, y, z, profnr, view, 1)
            # if feat["obj_typ"] != 'Fotoentzerrpunkt' or feat["prof_nr"] == '':
            if feat[FN_DEF_FOTOENTZERRPUNKT] != AW_FOTOENTZERRPUNKT or feat[FN_PROFILNUMMER] == "":
                ok = False
            feats.append(msgout)
        delLayer("Prof Entzerrpunkte AAR-Tool")
        box = QMessageBox()
        # ToDo: change following in: if not ok:
        if ok == False:
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle("Frage")
            box.setText("Manche Punkte sind keine Profilentzerrpunkte!")
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText("OK")
            buttonN = box.button(QMessageBox.No)
            buttonN.setText("Abbruch")
            box.exec_()
            if box.clickedButton() == buttonY:
                ok = True
            elif box.clickedButton() == buttonN:
                ok = False

        else:
            box = QMessageBox()
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle("Frage")
            box.setText("Export als ...?")
            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText("Templayer")
            buttonY.setToolTip("Erzeugt einen temporären Layer.")
            buttonN = box.button(QMessageBox.No)
            buttonN.setText("CSV-Datei")
            buttonN.setToolTip("Erzeugt eine CSV Datei.")
            buttonA = box.button(QMessageBox.Abort)
            buttonA.setText("Beides")
            buttonA.setToolTip("Erzeugt einen temporären Layer und eine CSV-Datei.")
            buttonY.setFocus()
            box.exec_()

            if box.clickedButton() == buttonN or box.clickedButton() == buttonA:
                # csv-Datei
                output_file = QFileDialog.getSaveFileName(
                    None,
                    "Speicherpfad",
                    QgsProject.instance().readPath(exportpfad),
                    "Excel (*.csv);;Excel (*.txt);;Alle Dateien (*.*)",
                )
                if output_file[0] != "":
                    # write to csv
                    output_file = open(output_file[0], "w")
                    for item in feats:
                        output_file.write(item.replace(" ", ""))
                    output_file.close()
            vl = None
            if box.clickedButton() == buttonY or box.clickedButton() == buttonA:
                # templayer erzeugen
                vl = QgsVectorLayer("Point", "Prof Entzerrpunkte AAR-Tool", "memory")
                # change memorylayer crs to layer crs
                vl.setCrs(profPointLayer.crs())
                pr = vl.dataProvider()
                pr.addAttributes(
                    [
                        QgsField("punktnr", QVariant.String, "text"),
                        QgsField("x", QVariant.Double, "double"),
                        QgsField("y", QVariant.Double, "double"),
                        QgsField("z", QVariant.Double, "double"),
                        QgsField("profilnr", QVariant.Int, "integer"),
                        QgsField("view", QVariant.String, "text"),
                        QgsField("points used", QVariant.Int, "integer"),
                    ]
                )
                vl.updateFields()
                feat = QgsFeature()
                for item in feats:
                    it = item.split(",")
                    point = QgsPoint(float(it[1]), float(it[2]), float(it[3]))
                    feat.setGeometry(QgsGeometry(point))
                    feat.setAttributes(
                        [str(it[0]), point.x(), point.y(), point.z(), int(it[4]), str(it[5]), int(it[6])]
                    )
                    pr.addFeatures([feat])
                    # QgsMessageLog.logMessage(str(it[1]), 'T2G Archäologie', Qgis.Info)
                # add memorylayer to canvas
                QgsProject.instance().addMapLayer(vl, False)
                root = QgsProject.instance().layerTreeRoot()
                g = root.findGroup("Vermessung")
                g.insertChildNode(0, QgsLayerTreeLayer(vl))
            delSelectFeature()

    def reverseLines(self):
        layer = self.iface.mapCanvas().currentLayer()
        if layer.geometryType() != QgsWkbTypes.LineGeometry:
            QMessageBox.information(None, "WICHTIG", "Falscher Geometrietyp!", QMessageBox.Cancel)
            return
        if layer.selectedFeatures() == []:
            QMessageBox.information(None, "WICHTIG", "Keine Geometrie gewählt!", QMessageBox.Cancel)
            return
        layer.startEditing()
        for feature in layer.selectedFeatures():
            geom = feature.geometry()
            if geom.isMultipart():
                mls = QgsMultiLineString()
                for line in geom.asGeometryCollection():
                    mls.addGeometry(line.constGet().reversed())
                newgeom = QgsGeometry(mls)
                layer.changeGeometry(feature.id(), newgeom)
            else:
                newgeom = QgsGeometry(geom.constGet().reversed())
                layer.changeGeometry(feature.id(), newgeom)

        layer.endEditCommand()
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()

    def showRasterGui(self):
        myDlgRasterLayerView = RasterLayerViewDockWidget(self.iface, self.iface.mapCanvas())
        myDlgRasterLayerView.setAutoFillBackground(True)
        myDlgRasterLayerView.show()

    # ----- End toolbar ------

    def eventReadProject(self):
        """Event Projekt geladen"""
        self.ProjPfad = os.path.abspath(QgsProject.instance().readPath(".."))

        # Config-Datei abarbeiten
        QgsMessageLog.logMessage("Projekt Config.ini laden.", self.plugin_name_tag, Qgis.Info)
        self.config = Configfile(os.path.join(self.ProjPfad, "_System_", "config.ini"))
        myDlgSettingsView = DlgSettings(self, self.config)
        myDlgSettingsView.setup()
        # Autosave einstellungen setzen
        autoSaveTime = self.config.getValue("AutoSave", "time", "10")
        autoSaveEnable = self.config.getValue("AutoSave", "enabled", "True")

        # ToDo: refactoring: watch (autosave?) needed?
        """
        if autoSaveEnable == 'True':
            self.watch.start(int(autoSaveTime) * 60000)
            QgsMessageLog.logMessage(
                "Auto Backup: An, " + "Takt " + autoSaveTime + " min", 'T2G Archäologie', Qgis.Info)
            self.iface.messageBar().pushMessage(uself.plugin_name_tag, u"Auto Backup: An, " + "Takt " + autoSaveTime + " min",
                                           level=Qgis.Info)
        else:
            self.watch.stop()
            QgsMessageLog.logMessage(
                "Auto Backup: Aus", 'T2G Archäologie', Qgis.Info)
            self.iface.messageBar().pushMessage(uself.plugin_name_tag, u"Auto Backup: Aus.",
                                           level=Qgis.Info)
        """

    def eventFeatureAdded(self, fid):
        # Wird nirgends mehr verwendet # Sonst Fehler beim Digitalisieren
        # self.newFeaturesIds.append(fid)
        QgsMessageLog.logMessage(str(fid) + " neu", self.plugin_name_tag, Qgis.Info)

    def eventEditingStarted(self):
        # QgsMessageLog.logMessage('Änderung Start', 'T2G Archäologie', Qgis.Info)
        # self.valueTemp1 = int(getCustomProjectVariable('nextBefNr'))
        # setCustomProjectVariable('maxWerteAktualisieren', 'False')
        QgsMessageLog.logMessage("Beginne Änderung", self.plugin_name_tag, Qgis.Info)
        self.__lastMaxNumber = []
        self.__lastMaxNumber.append(self.measurementTab.txtNextBef.text())
        self.__lastMaxNumber.append(self.measurementTab.txtNextFund.text())
        self.__lastMaxNumber.append(self.measurementTab.txtNextProf.text())
        self.__lastMaxNumber.append(self.measurementTab.txtNextProb.text())

    def __eventFeaturesDeleted(self, fid):
        setCustomProjectVariable("maxWerteAktualisieren", True)
        self.getMaxValues()
        setCustomProjectVariable("maxWerteAktualisieren", False)
        self.iface.mapCanvas().refreshAllLayers()

    def eventAttributeValueChanged(self, fid, idx, value, lyr):

        field = lyr.fields()[idx]
        QgsMessageLog.logMessage(
            f"Attribut in layer {lyr.name()} geändert: id={fid}, field={field.name()}, value={value}",
            self.plugin_name_tag,
            Qgis.Info,
        )
        if isNumber(str(value)):
            if field.name() == "bef_nr":
                if int(value) >= int(self.__lastMaxNumber[0]):
                    self.measurementTab.txtNextBef.setText(str(int(value) + 1))
                else:
                    self.dockwidget.txtNextBef.setText(str(self.__lastMaxNumber[0]))
            elif field.name() == "fund_nr":
                if int(value) >= int(self.__lastMaxNumber[1]):
                    self.measurementTab.txtNextFund.setText(str(int(value) + 1))
                else:
                    self.measurementTab.txtNextFund.setText(str(self.__lastMaxNumber[1]))
            elif field.name() == "prof_nr":
                if int(value) >= int(self.__lastMaxNumber[2]):
                    self.measurementTab.txtNextProf.setText(str(int(value) + 1))
                else:
                    self.dockwidget.txtNextProf.setText(str(self.__lastMaxNumber[2]))
            elif field.name() == "prob_nr":
                if int(value) >= int(self.__lastMaxNumber[3]):
                    self.measurementTab.txtNextProb.setText(str(int(value) + 1))
                else:
                    self.measurementTab.txtNextProb.setText(str(self.__lastMaxNumber[3]))

    def filterGesetzt(self):
        # QgsMessageLog.logMessage('filter gesetzt', 'T2G Archäologie', Qgis.Info)
        list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
        for layer in list:
            # QgsMessageLog.logMessage(layer.source(), 'T2G Archäologie', Qgis.Info)
            if "subset" in layer.source():
                self.measurementTab.txtNextBef.setText("xxxxx")
                self.measurementTab.txtNextFund.setText("xxxxx")
                self.measurementTab.txtNextProf.setText("xxxxx")
                self.measurementTab.txtNextProb.setText("xxxxx")
                # QgsMessageLog.logMessage('Filter gesetzt', 'T2G Archäologie', Qgis.Info)

    # ToDo: refactoring - consistent with auto attributes in Tab "Vermessung"?
    def currentLayerChanged(self):
        setCustomProjectVariable("obj_typ", "")
        setCustomProjectVariable("obj_art", "")
        setCustomProjectVariable("schnitt_nr", "")
        setCustomProjectVariable("bef_nr", "")
        setCustomProjectVariable("planum_nr", "")
        setCustomProjectVariable("fund_nr", "")
        setCustomProjectVariable("prob_nr", "")
        setCustomProjectVariable("prof_nr", "")
        setCustomProjectVariable("material", "")
        setCustomProjectVariable("pt_nr", "")
        setCustomProjectVariable("autoAttribute", "False")
        setCustomProjectVariable("autoZahl", "False")
        setCustomProjectVariable("maxWerteAktualisieren", True)
        setCustomProjectVariable("SignalGeometrieNeu", "False")

    # ToDo: refactoring - tab: "Tools Raster"
    def setCutMask(self):
        cutlayer = QgsProject.instance().mapLayersByName("Schnittmaske")[0]
        actlayer = None
        for layer in QgsProject.instance().mapLayers().values():
            if layer.type() == QgsMapLayer.VectorLayer:
                if layer.selectedFeatureCount() > 0:
                    actlayer = layer
                    break
        if actlayer == None:
            self.iface.messageBar().pushMessage(
                self.plugin_name_tag, "Keine Objekte gewählt! Abbruch", level=Qgis.Critical
            )
            return
        self.iface.actionCopyFeatures().trigger()
        self.iface.setActiveLayer(cutlayer)
        cutlayer.startEditing()
        self.iface.actionPasteFeatures().trigger()
        cutlayer.commitChanges()
        delSelectFeature()
        self.iface.actionSelectRectangle().trigger()

    # ToDo: refactoring - tab: "Tools Raster"
    def delCutMask(self):
        cutlayer = QgsProject.instance().mapLayersByName("Schnittmaske")[0]
        cutlayer.startEditing()
        listOfIds = [feat.id() for feat in cutlayer.getFeatures()]
        cutlayer.deleteFeatures(listOfIds)
        cutlayer.commitChanges()
        self.iface.messageBar().pushMessage(self.plugin_name_tag, "Maskenlayer gelöscht", level=Qgis.Info)

    # ToDo: refactoring - tab: "Tools Raster"
    def rasterCut(self):
        # Layer des zu schneidenden Bildes
        layer = self.iface.mapCanvas().currentLayer()

        if layer.type() != QgsMapLayer.RasterLayer:
            self.iface.messageBar().pushMessage(
                self.plugin_name_tag, "Layer ist kein Rasterlayer!", level=Qgis.Critical
            )
            return

        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle("Frage")
        box.setText("Neue Schnittmaske erstellen oder vorh. Maske verwenden.")
        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText("Neu")
        buttonY.setToolTip("Erstellt eine Schnittmaske durch zeichnen eines Polygons.")
        buttonN = box.button(QMessageBox.No)
        buttonN.setText("vorh. Maske")
        buttonN.setToolTip("Nutzt die Objekte im Layer Schnittmaske")
        box.exec_()
        # Layer mit Schnittmaske/n in Variable speichern und activ setzen
        cutlayer = QgsProject.instance().mapLayersByName("Schnittmaske")[0]
        self.iface.setActiveLayer(cutlayer)
        # Auswahl neue Schnittmaske
        if box.clickedButton() == buttonY:
            # Schnittmasken Layer zum editing öffnen
            cutlayer.startEditing()
            # alle Geometrien löschen
            listOfIds = [feat.id() for feat in cutlayer.getFeatures()]
            cutlayer.deleteFeatures(listOfIds)
            # Qgis Kartenfenster aktuallisieren
            self.iface.mapCanvas().refresh()
            # Aktion Neues Objekt auslösen
            self.iface.actionAddFeature().trigger()
            # Warten bis ein neues Objekt gezeichnet wurde
            while cutlayer.featureCount() < 1:
                QApplication.processEvents()
            # Änderungen übernehmen
            cutlayer.commitChanges()
        # Auswahl Vorhandene Schnittmaske
        elif box.clickedButton() == buttonN:
            if cutlayer.featureCount() == 0:
                self.iface.messageBar().pushMessage(
                    self.plugin_name_tag, "Keine Objekte auf Maskenlayer vorhanden! Abbruch", level=Qgis.Critical
                )
                return
        else:
            # Bei keiner Auswahl Abbruch
            return
        # Layer des zu schneidenden Bildes aktiv setzen
        self.iface.setActiveLayer(layer)

        # Layerpfad in Variable speichern
        input_path = os.path.abspath(str(layer.source()))
        # Programmteil zum schneideen des Bildes
        try:
            # Maskenlayerpfad in Variable speichern
            masklayerpfad = str(cutlayer.source()).split("|")[0]
            masklayername = "Schnittmaske"
            # Layer Koordinatensysteme in Variable speichern
            inputsrs = layer.crs().authid()
            outputsrs = layer.crs().authid()

            temp_input_raster = None
            temp_output_raster = None
            # Pfad Eingaberaster in Variable speichern
            temp_input_raster = input_path
            # Pfad Ausgaberaster in Variable speichern
            temp_output_raster = os.path.splitext(input_path)[0] + "_cut" + os.path.splitext(input_path)[1]

            items = ("keine", "75", "50", "25")
            kompress = None
            kompressv, ok = QInputDialog.getItem(None, "Kompression", "JPEG-Qualität eingeben", items, 0, False)
            if ok != True:
                # Abbruch
                return
            else:
                # Kompressionsvariable setzen
                if kompressv == "keine":
                    kompress = ""
                else:
                    kompress = "-co COMPRESS=JPEG -co JPEG_QUALITY=" + kompressv
            # Gdal Komandozeile zusammensetzen
            string = (
                r"gdalwarp"
                + " -s_srs "
                + inputsrs
                + " -t_srs "
                + outputsrs
                + ' -of GTiff -cutline "'
                + masklayerpfad
                + '" -cl '
                + masklayername
                + " -crop_to_cutline -dstalpha "
                + kompress
                + ' "'
                + temp_input_raster
                + '" "'
                + temp_output_raster
                + '"'
            )
            # Komandozeile an System senden
            os.system(string)
            # Speicherdialog aufrufen
            dlg = QFileDialog()
            initFilter = ""
            if temp_input_raster[:3] == "jpg":
                initFilter = "Jpeg mit World (*.jpg)"
            elif temp_input_raster[:3] == "tif":
                initFilter = "GeoTif (*.tif)"

            output_file = dlg.getSaveFileName(
                None,
                "Speicherpfad",
                input_path,
                "GeoTif (*.tif);;Jpeg mit World (*.jpg);;Alle (*.*)",
                initialFilter=initFilter,
            )
            # Ausgewähltes Ausgabeformat auswerten
            if output_file[1] == "GeoTif (*.tif)":
                s = os.path.splitext(output_file[0])[0]
                # temp. geschnittenes Bild unter neuen Namen speichern
                fileFunc().file_copy(temp_output_raster, s + ".tif")
                # Bild als neuen Layer einfügen
                self.iface.addRasterLayer(s + ".tif", os.path.basename(output_file[0])[:-4])

            elif output_file[1] == "Jpeg mit World (*.jpg)":
                s = os.path.splitext(output_file[0])[0]
                temp_input_raster = temp_output_raster
                temp_output_raster_transl = s + ".jpg"
                # Gdal Komandozeile zusammensetzen umwandlung zu Jpeg
                string = (
                    r'gdal_translate -of Jpeg -co worldfile=yes -mask 4 "'
                    + temp_input_raster
                    + '" "'
                    + temp_output_raster_transl
                    + '"'
                )
                # Komandozeile an System senden
                os.system(string)
                # Bild als neuen Layer einfügen
                rasterlayer = self.iface.addRasterLayer(s + ".jpg", os.path.basename(output_file[0])[:-4])
                # Layer Koordinatensystem setzen
                rasterlayer.setCrs(QgsCoordinateReferenceSystem(outputsrs))
        except Exception as e:
            QgsMessageLog.logMessage(str(e), self.plugin_name_tag, Qgis.Info)
            # temp. geschnittenes Bild löschen
            fileFunc().file_del(temp_output_raster)
        finally:
            QgsMessageLog.logMessage("datei löschen", self.plugin_name_tag, Qgis.Info)
            # temp. geschnittenes Bild löschen
            fileFunc().file_del(temp_output_raster)

        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle("Frage")
        box.setText("Ausgangsdatei löschen?")
        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText("Datei und Layer")
        buttonY.setToolTip("Löscht Datei und Layer")
        buttonN = box.button(QMessageBox.No)
        buttonN.setText("Layer")
        buttonN.setToolTip("Löscht nur denn Layer")
        buttonA = box.button(QMessageBox.Abort)
        buttonA.setText("Behalten")
        buttonA.setToolTip("Löscht keins von beiden")
        buttonA.setFocus()
        box.exec_()

        if box.clickedButton() == buttonY:
            QgsProject.instance().removeMapLayer(layer.id())
            a = 0
            for layer in QgsProject.instance().mapLayers().values():
                QgsMessageLog.logMessage(layer.source(), self.plugin_name_tag, Qgis.Info)
                if input_path in layer.source():
                    a = a + 1
            if a == 0:
                fileFunc().file_del(input_path)
            else:
                self.iface.messageBar().pushMessage(
                    self.plugin_name_tag,
                    "Datei ist mehrfach als Layer eingefügt und kann nicht gelöscht werden.",
                    level=Qgis.Critical,
                )
        elif box.clickedButton() == buttonN:
            QgsProject.instance().removeMapLayer(layer.id())
            pass
        elif box.clickedButton() == buttonA:
            pass

    # ToDo: refactoring - tab "Raster Tools"
    def gtiff2jpg(self):
        layer = self.iface.mapCanvas().currentLayer()
        if layer.type() == QgsMapLayer.RasterLayer and layer.source()[-3:] == "tif":
            # self.file2temp()
            input_path = os.path.abspath(str(layer.source()))
            outputsrs = layer.crs().authid()
            QgsMessageLog.logMessage(input_path, self.plugin_name_tag, Qgis.Info)

            try:
                layername = layer.name()
                input_path = str(layer.source())

                inputtemp = input_path  # r'C:/temp/#T2G-Arch#/temp.tif'
                # r'C:/temp/#T2G-Arch#/temp_transf.jpg'
                outputtemp = os.path.splitext(input_path)[0] + "_transf" + os.path.splitext(input_path)[1]

                string = (
                    r"gdal_translate -of JPEG -scale -co worldfile=yes " + '"' + inputtemp + '" "' + outputtemp + '"'
                )
                os.system(string)

                output_file = QFileDialog.getSaveFileName(
                    None, "Speicherpfad", os.path.splitext(input_path)[0], "Jpeg mit World (*.jpg);;Alle (*.*)"
                )
                if output_file[0] != "":
                    fileFunc().file_copy(outputtemp, output_file[0][:-4] + ".jpg")
                    fileFunc().file_copy(outputtemp[:-4] + ".wld", output_file[0][:-4] + ".wld")

                    rasterlayer = self.iface.addRasterLayer(
                        output_file[0][:-4] + ".jpg", os.path.basename(output_file[0])[:-4]
                    )
                    rasterlayer.setCrs(QgsCoordinateReferenceSystem(outputsrs))

                    box = QMessageBox()
                    box.setIcon(QMessageBox.Question)
                    box.setWindowTitle("Frage")
                    box.setText("Datei löschen?")
                    box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Abort)
                    buttonY = box.button(QMessageBox.Yes)
                    buttonY.setText("GeoTIF")
                    buttonY.setToolTip("Löscht GeoTiff und Layer")
                    buttonN = box.button(QMessageBox.No)
                    buttonN.setText("Layer")
                    buttonN.setToolTip("Löscht denn Layer")
                    buttonA = box.button(QMessageBox.Abort)
                    buttonA.setText("Behalten")
                    buttonA.setToolTip("Löscht keins von beiden")
                    buttonA.setFocus()
                    box.exec_()

                    if box.clickedButton() == buttonY:
                        QgsProject.instance().removeMapLayer(layer.id())
                        a = 0
                        for layer in QgsProject.instance().mapLayers().values():
                            QgsMessageLog.logMessage(layer.source(), self.plugin_name_tag, Qgis.Info)
                            if input_path in layer.source():
                                a = a + 1
                        if a == 0:
                            fileFunc().file_del(input_path)
                            fileFunc().file_del(input_path[:-4] + ".wld")
                        else:
                            self.iface.messageBar().pushMessage(
                                self.plugin_name_tag,
                                "Datei ist mehrfach als Layer eingefügt und kann nicht gelöscht werden.",
                                level=Qgis.Critical,
                            )
                    elif box.clickedButton() == buttonN:
                        QgsProject.instance().removeMapLayer(layer.id())

                    elif box.clickedButton() == buttonA:
                        pass

            except Exception as e:
                QgsMessageLog.logMessage(str(e), self.plugin_name_tag, Qgis.Info)
            finally:
                fileFunc().file_del(outputtemp)
                fileFunc().file_del(outputtemp[:-4] + ".wld")
                fileFunc().file_del(outputtemp[:-4] + ".tif.aux.xml")
        else:
            self.iface.messageBar().pushMessage(
                self.plugin_name_tag, "Layer ist kein Rasterlayer oder eine GeoTif!", level=Qgis.Critical
            )

    # ToDo: refactoring - increments values in measurement tab
    def getMaxValues(self):
        if getCustomProjectVariable("maxWerteAktualisieren") == True:
            layerLine = QgsProject.instance().mapLayersByName("E_Line")[0]
            layerPoly = QgsProject.instance().mapLayersByName("E_Polygon")[0]
            layerPoint = QgsProject.instance().mapLayersByName("E_Point")[0]
            layerlist = [layerLine, layerPoly, layerPoint]

            BefNrMax = 0
            FundNrMax = 0
            ProfNrMax = 0
            ProbNrMax = 0

            for layer in layerlist:
                if len([feat["bef_nr"] for feat in layer.getFeatures()]) > 0:
                    max1 = maxValue(layer, "bef_nr")
                    # QgsMessageLog.logMessage(str(max1), 'T2G Archäologie', Qgis.Info)
                    if BefNrMax < max1:
                        BefNrMax = max1
                if len([feat["fund_nr"] for feat in layer.getFeatures()]) > 0:
                    max2 = maxValue(layer, "fund_nr")
                    if FundNrMax < max2:
                        FundNrMax = max2
                try:
                    if len([feat["prob_nr"] for feat in layer.getFeatures()]) > 0:
                        max3 = maxValue(layer, "prob_nr")
                        if ProbNrMax < max3:
                            ProbNrMax = max3
                except Exception as e:
                    QgsMessageLog.logMessage(str(e), self.plugin_name_tag, Qgis.Info)

                try:
                    if len([feat["prof_nr"] for feat in layer.getFeatures()]) > 0:
                        max4 = maxValue(layer, "prof_nr")
                        if ProfNrMax < max4:
                            ProfNrMax = max4
                except Exception as e:
                    QgsMessageLog.logMessage(str(e), self.plugin_name_tag, Qgis.Info)

                self.measurementTab.txtNextBef.setText(str(BefNrMax + 1))
                self.measurementTab.txtNextFund.setText(str(FundNrMax + 1))
                self.measurementTab.txtNextProf.setText(str(ProfNrMax + 1))
                self.measurementTab.txtNextProb.setText(str(ProbNrMax + 1))

                setCustomProjectVariable("nextBefNr", str(BefNrMax + 1))
                setCustomProjectVariable("nextProfNr", str(ProfNrMax + 1))
                setCustomProjectVariable("nextFundNr", str(FundNrMax + 1))
                setCustomProjectVariable("nextProbNr", str(ProbNrMax + 1))

            self.iface.messageBar().pushMessage(
                self.plugin_name_tag, "Nächste zu vergebende Nummern wurden aktuallisiert.", level=Qgis.Info
            )
            setCustomProjectVariable("maxWerteAktualisieren", False)
            # self.autoNummer()

    # ToDo: Refactoring, "Befundnummer setzen" in "Tools Allgemein"
    def setBefundLabel_n(self):
        pass
        """
        self.__abbruch = False
        self.iface.messageBar().clearWidgets()
        widgetMessage = self.iface.messageBar().createMessage('Befundlabel setzen abrechen.')
        button = QPushButton(widgetMessage)
        button.setText("Abbruch")
        button.pressed.connect(self.__setAbbruch)
        widgetMessage.layout().addWidget(button)
        self.iface.messageBar().pushWidget(widgetMessage, Qgis.Info)

        self.__delAutoAttribut()
        self.__koordtableClear()
        self.__dockwidget.chbAutoAtt.setChecked(True)
        self.__dockwidget.chbAttributtable.setChecked(False)
        self.__dockwidget.chbbefZ.setChecked(False)
        self.__dockwidget.cboobjTyp.setCurrentText('Kartenbeschriftung')
        self.__dockwidget.cboobjArt.setCurrentText('Befund')
        self.__dockwidget.txtBefNr.setText('')
        #return
        var = 0
        while self.__abbruch == False:
            if not self.__dockwidget.chbbefZ.isChecked():
                while self.__verticesCount == 0:
                    QApplication.processEvents()
                    pass
                if self.__abbruch == True:
                    break
                self.__watchEvent()
                befnr, ok = QInputDialog().getText(None, '', 'Befund Nr. eingeben')
                if ok:
                    self.__dockwidget.txtBefNr.setText(befnr)
                    self.__geometryIdentify()
                    if not self.__dockwidget.chbbefZ.isChecked() and var == 0:
                        box = QMessageBox()
                        box.setIcon(QMessageBox.Question)
                        box.setText('Soll die Befundnummer hochgezählt werden?')
                        box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                        buttonY = box.button(QMessageBox.Yes)
                        buttonY.setText('Ja')
                        buttonN = box.button(QMessageBox.No)
                        buttonN.setText('Nein')
                        box.exec_()
                        var = 1
                        if box.clickedButton() == buttonY:
                            self.__dockwidget.chbbefZ.setChecked(True)
                            self.__dockwidget.txtBefNr.setText(str(int(befnr)+1))
                else:
                    self.__abbruch = True
                    self.iface.messageBar().popWidget()
            QApplication.processEvents()
        self.__dockwidget.butBefundLabel.setStyleSheet("")
        """

    # ToDo: refactoring - tab "Tools Allgemein"
    def ozoom_1_ok(self):
        # layer = QgsProject.instance().mapLayer(self.dockwidget.cbo_ozoom_1.currentLayer().id())
        layer = self.iface.activeLayer()
        layerLine = QgsProject.instance().mapLayersByName("E_Line")[0]
        layerPoly = QgsProject.instance().mapLayersByName("E_Polygon")[0]
        layerPoint = QgsProject.instance().mapLayersByName("E_Point")[0]
        layerlist = [layerLine, layerPoly, layerPoint]
        labellist = [self.dockwidget.labE_Line, self.dockwidget.labE_Poly, self.dockwidget.labE_Poi]
        layer.removeSelection()
        suchstr, ok = QInputDialog.getText(None, "Suchen", "Nummer eingeben")
        if ok:
            if self.dockwidget.cboSuche.currentText() == "Befund":
                fieldName = "bef_nr"
            if self.dockwidget.cboSuche.currentText() == "Fund":
                fieldName = "fund_nr"
            if self.dockwidget.cboSuche.currentText() == "Profil":
                fieldName = "prof_nr"
            if self.dockwidget.cboSuche.currentText() == "Probe":
                fieldName = "prob_nr"
            if suchstr[0] == "":
                return
            if isNumber(suchstr[0]):
                suchstr = fieldName + "=" + suchstr
            else:
                suchstr = fieldName + "=" + "'" + suchstr + "'"
        else:
            return
        expr = QgsExpression(suchstr)  # QgsExpression("befNr='120'")
        a = 0
        meldung = True
        for layer in layerlist:
            a = a + 1
            QgsMessageLog.logMessage(str(suchstr), self.plugin_name_tag, Qgis.Info)
            it = layer.getFeatures(QgsFeatureRequest(expr))
            ids = [i.id() for i in it]
            layer.selectByIds(ids)
            # self.dockwidget.lab_oselc_1.setText (str(layer.selectedFeatureCount()))

            if layer.selectedFeatureCount() > 0:
                self.iface.mapCanvas().zoomToSelected(layer)
                if not layer.geometryType() == QgsWkbTypes.PointGeometry:
                    self.iface.mapCanvas().zoomByFactor(5)
                self.iface.mapCanvas().refresh()
                labellist[a - 1].setText(str(layer.selectedFeatureCount()))
                meldung = False
            else:
                labellist[a - 1].setText(str(layer.selectedFeatureCount()))
                if meldung != False:
                    meldung = True
        if meldung == True:
            QMessageBox.warning(None, "Meldung", "Keine Objekte gefunden!")

    # ToDo: refactoring - tab "Tools Allgemein"
    def delAllFeature(self):
        result = QMessageBox.warning(
            None,
            "Achtung",
            "Wollen Sie wirklich alle Objekte\n auf den Eingabelayern löschen?",
            QMessageBox.Ok,
            QMessageBox.Abort,
        )
        if result == QMessageBox.Ok:
            layer_list = [self.layerPoly, self.layerLine, self.layerPoint, self.layerMesspoint]
            for layer in layer_list:
                # layer =  QgsProject.instance().mapLayersByName(layername)[0]
                layer.startEditing()
                QgsMessageLog.logMessage(
                    "Alle Objekte auf Layer " + layer.name() + " gelöscht.", self.plugin_name_tag, Qgis.Info
                )
                listOfIds = [feat.id() for feat in layer.getFeatures()]
                layer.deleteFeatures(listOfIds)
                layer.commitChanges()
        else:
            QgsMessageLog.logMessage("Abbruch", self.plugin_name_tag, Qgis.Info)

    # ToDo: refactoring- Tab "Tools Allgemein"
    def myDlgFeatureCheckShow(self):
        self.myDlgFeatureCheck = GeometryCheckDockWidget(self.iface, self.iface.mapCanvas())  # mainWindow()
        self.myDlgFeatureCheck.setAutoFillBackground(True)
        self.myDlgFeatureCheck.show()

    # ToDo: refactoring - Tab: "Tool Raster"
    def myDlgRasterLayerShow(self):
        myDlgRasterLayerView = RasterLayerViewDockWidget(self.iface, self.iface.mapCanvas())  # mainWindow()
        myDlgRasterLayerView.setAutoFillBackground(True)
        myDlgRasterLayerView.show()

    # ToDo: open pdf
    def help(self):
        QMessageBox.information(None, "Hilfe", os.path.join(self.ProjPfad, "Hinweise.pdf"), QMessageBox.Cancel)
        # subprocess.Popen([os.path.join(self.ProjPfad,
        #                              'Hinweise.pdf')],
        #                              shell=True)

    def myDlgSettingsShow(self):
        myDlgSettingsView = DlgSettings(self, self.config)  # mainWindow()
        myDlgSettingsView.setup()
        # myDlgSettingsView.setAutoFillBackground(True)
        myDlgSettingsView.show()

    # ToDo: refactoring - watch (autosave?) needed?
    def watchEvent(self):
        ProjectSaveFunc().shapesSave()
        origFileName = QgsProject.instance().fileName()
        if origFileName != "":  # and QgsProject.instance().isDirty()
            bakFileName = origFileName + ".bak"
            fileFunc().file_del(bakFileName)
            QgsProject.instance().write()
            QgsProject.instance().write(bakFileName)
            QgsProject.instance().setFileName(origFileName)

        # if projectSaveFunc().project_save(unicode(self.ProjPfad)) == 'False':
        #    self.iface.messageBar().pushMessage(uself.plugin_name_tag, u"Auto Backup: Fehler!",
        #                                   level=Qgis.Critical)
        #    QgsMessageLog.logMessage("Auto Backup: Fehler!", 'T2G Archäologie', Qgis.Critical)
        # else:
        #    self.iface.messageBar().pushMessage(uself.plugin_name_tag, u"Auto Backup: Erstellt!",
        #                                   level=Qgis.Info)
        #    QgsMessageLog.logMessage("Auto Backup: Erstellt.", 'T2G Archäologie', Qgis.Info)

        ziel = os.path.join(self.ProjPfad, "_Sicherungen_")

        # Temporärer Fix - Diskussion wie und ob Sicherung
        if os.path.isdir(ziel):
            ordner = []

            for folder in next(os.walk(ziel))[1]:
                ordner.append((str(folder)))

            for i in range(0, len(ordner) - 5):
                fileFunc().directory_del(os.path.join(ziel, ordner[i]))

    # ToDo: refactoring - Map Tools
    def editFeature(self, layer, feature):
        delSelectFeature()
        self.selectedLayer = layer
        self.selectedFeature = feature
        koordlist = []
        z = []
        contextMenu = QMenu()
        if layer.type() == QgsMapLayer.RasterLayer:
            pass

        # multipart
        elif self.selectedFeature.geometry().isMultipart():
            parts = self.selectedFeature.geometry().asGeometryCollection()
            if self.selectedLayer.geometryType() == QgsWkbTypes.PointGeometry:
                for part in parts:
                    for vertex in part.vertices():
                        m = self.pointMaker
                        m.setMaker(vertex.x(), vertex.y())
                pass

            else:
                koordlist = []
                for part in parts:
                    for vertex in part.vertices():
                        koordlist.append({0: vertex.x(), 1: vertex.y(), 2: vertex.z()})
                        z.append(vertex.z())
                    r = self.rubberBand
                    r.setRubberBandPoly(koordlist, 3)

            contextMenu.addAction("Z min:  " + str(round(min(z), 2)))
            contextMenu.addAction("Z max:  " + str(round(max(z), 2)))
        else:
            # singlepart
            if self.selectedLayer.geometryType() == QgsWkbTypes.PointGeometry:
                self.pointMaker.setMarker(
                    self.selectedFeature.geometry().get().x(), self.selectedFeature.geometry().get().y(), 12, 2
                )
                contextMenu.addAction("X: " + str(self.selectedFeature.geometry().get().x()))
                contextMenu.addAction("Y: " + str(self.selectedFeature.geometry().get().y()))
                contextMenu.addAction("Z: " + str(self.selectedFeature.geometry().get().z()))
            elif layer.geometryType() == QgsWkbTypes.LineGeometry:
                n = len(self.selectedFeature.geometry().asPolyline()[0])
                z = []
                koordlist = []
                for i in range(n):
                    z.append(float(self.selectedFeature.geometry().vertexAt(i).z()))
                    koordlist.append(
                        {
                            "x": self.selectedFeature.geometry().vertexAt(i).x(),
                            "y": self.selectedFeature.geometry().vertexAt(i).y(),
                            "z": self.selectedFeature.geometry().vertexAt(i).z(),
                        }
                    )
                self.rubberBand.setRubberBandPoly(koordlist, 3)
                contextMenu.addAction("Z min:  " + str(round(min(z), 2)))
                contextMenu.addAction("Z max:  " + str(round(max(z), 2)))

                zmit = ((max(z) - min(z)) / 2) + round(min(z), 2)
                contextMenu.addAction("Z mit:  " + str(round(zmit, 2)))
                contextMenu.addAction("Länge:  " + str(round(self.selectedFeature.geometry().length(), 2)) + " m")
            elif self.selectedLayer.geometryType() == QgsWkbTypes.PolygonGeometry:
                z = []
                n = self.selectedFeature.geometry().asPolygon()[0]
                for i in range(len(n)):
                    koordlist.append(
                        {
                            "x": self.selectedFeature.geometry().vertexAt(i).x(),
                            "y": self.selectedFeature.geometry().vertexAt(i).y(),
                            "z": self.selectedFeature.geometry().vertexAt(i).z(),
                        }
                    )
                    z.append(float(self.selectedFeature.geometry().vertexAt(i).z()))
                self.rubberBand.setRubberBandPoly(koordlist, 3)

                contextMenu.addAction("Z min:  " + str(round(min(z), 2)))
                contextMenu.addAction("Z max:  " + str(round(max(z), 2)))

                zmit = ((max(z) - min(z)) / 2) + round(min(z), 2)
                contextMenu.addAction("Z mit:  " + str(round(zmit, 2)))
                contextMenu.addAction("Fläche:  " + str(round(self.selectedFeature.geometry().area(), 2)) + " m2")

        # contextMenu.setStyleSheet("QMenu { Background-color : rgb(217, 241, 255) ; color : rgb(20, 50, 255)}")
        contextMenu.addAction("Layername: " + str(layer.name()))
        dlgFeatureQuestionTableShow = contextMenu.addAction(
            QIcon(QgsApplication.iconPath("mActionOpenTable")), "Attributtabelle"
        )
        dlgFeatureQuestionTableShow.triggered.connect(self.showAttributeTable)
        dlgFeatureQuestionShow = contextMenu.addAction(QIcon(ICON_PATHS["Formular"]), "Geometriedaten")
        dlgFeatureQuestionShow.triggered.connect(self.myDlgFeatureQuestionShow)
        # contextMenu.addSeparator()
        FeatureSelect = contextMenu.addAction(QIcon(ICON_PATHS["FeatureSelect.gif"]), "Geometrie auswählen")
        FeatureSelect.triggered.connect(self.featureSelect)
        # FeatureSelectExit = contextMenu.addAction(
        #    QIcon(ICON_PATHS["FeatureSelect.gif"]), "Auswahl beenden.")
        # FeatureSelectExit.triggered.connect(self.featureSelectedExit)
        QgsMessageLog.logMessage(str(feature.id()), self.plugin_name_tag, Qgis.Info)
        contextMenu.addSeparator()

        attrs = self.selectedFeature.attributes()
        fields = self.selectedFeature.fields().toList()

        for i, attr in enumerate(attrs):
            name = fields[i].name()
            if str(attr) == "NULL":
                attr = ""
            if name == "aktcode":
                contextMenu.addAction("Grabung:  " + str(attr))
            if name == "obj_typ":
                contextMenu.addAction("Objekttyp:  " + str(attr))
            if name == "obj_art":
                contextMenu.addAction("Objektart:  " + str(attr))
            if name == "schnitt_nr":
                contextMenu.addAction("Schnitt-Nr:  " + str(attr))
            if name == "bef_nr":
                contextMenu.addAction("Befund-Nr:  " + str(attr))
            if name == "fund_nr":
                contextMenu.addAction("Fund-Nr:  " + str(attr))
            if name == "prof_nr":
                contextMenu.addAction("Profil-Nr:  " + str(attr))
            if name == "planum_nr":
                contextMenu.addAction("Planum:  " + str(attr))
            if name == "material":
                contextMenu.addAction("Material:  " + str(attr))
            if name == "geo-arch":
                contextMenu.addAction("geo/arch:  " + str(attr))
            if name == "pt_nr":
                contextMenu.addAction("Punkt-Nr:  " + str(attr))
        contextMenu.addAction("-----------------------")

        contextMenu.exec_(QCursor.pos())
        self.rubberBand.rubberBandClean()
        self.pointMaker.makerClean()

    # ToDo: refactoring: editFeature/ map tools - helper
    def featureSelect(self):
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))

    # ToDo: refactoring: editFeature - helper
    def showAttributeTable(self):
        self.iface.setActiveLayer(self.selectedLayer)
        self.selectedLayer.select(int(self.selectedFeature.id()))
        query = "id = " + str(int(self.selectedFeature.attributes()[0]))
        self.iface.showAttributeTable(self.selectedLayer, query)

    def selectFeatureChanged(self, fselected, fdeselected):
        QgsMessageLog.logMessage("sel" + str(fselected), self.plugin_name_tag, Qgis.Info)
        for value in fselected:
            if len(fselected) == 1:
                layer = getlayerSelectedFeatures()
                QgsMessageLog.logMessage("eins selectiert" + str(fselected), self.plugin_name_tag, Qgis.Info)
                QgsMessageLog.logMessage(
                    "select " + str(layer.name()) + " " + str(fselected), self.plugin_name_tag, Qgis.Info
                )
                self.selFeatureTemp = layer.selectedFeatures()[0]
            if value in self.selectFeatures:
                pass
            else:
                self.selectFeatures.append(value)
        QgsMessageLog.logMessage("desel" + str(fdeselected), self.plugin_name_tag, Qgis.Info)
        for value in fdeselected:
            if value in self.selectFeatures:
                self.selectFeatures.remove(value)
        QgsMessageLog.logMessage("liste" + str(self.selectFeatures), self.plugin_name_tag, Qgis.Info)

    def _is_project_from_tachy_geopackage(self):
        if not QgsProject.instance().fileName():
            # kein Projekt geladen
            print("no project loaded")
            return False

        file_extension = QgsProject.instance().fileName().split(".")[-1].lower()
        if file_extension != "qgz":
            print("file extension is not qgz")
            return False

        layers_check_for_existence = ["E_Line", "E_Point", "E_Polygon"]
        for layer in layers_check_for_existence:
            if not QgsProject.instance().mapLayersByName(layer):
                print(f"layer {layer} not found")
                return False

        layers_check_gpkg_source = ["E_Line", "E_Point", "E_Polygon"]
        for layer in QgsProject.instance().mapLayers().values():
            # print(f"{layer.name()} {layer.dataProvider().dataSourceUri()}")
            if layer.name() in layers_check_gpkg_source and not layer.dataProvider().dataSourceUri().split("|")[
                0
            ].lower().endswith(".gpkg"):
                print(f"data source is no gpkg: {layer.name()} {layer.dataProvider().dataSourceUri()}")
                return False

        return True
